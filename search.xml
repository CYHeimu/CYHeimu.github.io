<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Codeforces Round #791 (Div. 2) A-C 题解</title>
    <url>/2022/05/15/Codeforces-Round-791-Div-2-A-C-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1679">Codeforces Round #791 (Div. 2)</a></p>
<p>可能与正解有出入，只是展示了自己的写法。</p>
<h1 id="A-AvtoBus"><a href="#A-AvtoBus" class="headerlink" title="A. AvtoBus"></a>A. AvtoBus</h1><p>给定一个数 n ，使用 4 和 6 分割这个数，如果不能完美分割输出 -1 ，如果能则输出最小分割数和最大分割数。</p>
<p>有两种情况不能完美分割，即 n 不能被 2 整除和 n 小于 4 的时候，这两种情况都很好理解，输出 -1 即可。</p>
<p>4 和 6 都是 2 的倍数，因此不妨计算 n&#x2F;2 被 2 和 3 分割。分别计算最小分割数和最大分割数。</p>
<p><strong>最小分割数：</strong></p>
<p>由于是最小分割，因此要尽可能分出更多的 3 ，分完之后的余数可能为 0，1，2。余数为 0 ，刚好分割完，分割数不变；余数为 1 ，那么便从分割好的 3 中拿出一个凑成 4 ，再分割为 2 个 2，即分割数 + 1；余数为 2 ，直接多分割一个 2 ，分割数 + 1。若一个 3 都分割不出来，即 n &#x3D; 2 的情况，直接等于最大分割数。</p>
<p><strong>最大分割数：</strong></p>
<p>由于是最小分割，因此要尽可能分出更多的 2 ，分完之后的余数可能为 0，1。余数为 0 ，刚好分割完，分割数不变；余数为 1 ，那么便从分割好的 2 中拿出一个凑成 3 ，即分割 1 个 3 ，分割数不变。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">ll n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solv</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(n%<span class="number">2</span>||n&lt;<span class="number">4</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	n/=<span class="number">2</span>;</span><br><span class="line">	</span><br><span class="line">	ll min=n/<span class="number">3</span>,max=n/<span class="number">2</span>;</span><br><span class="line">	ll temp=n-(n/<span class="number">3</span>*<span class="number">3</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(temp) min++;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(min==<span class="number">0</span>) min=max;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>,min,max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++) <span class="built_in">solv</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-Stone-Age-Problem"><a href="#B-Stone-Age-Problem" class="headerlink" title="B. Stone Age Problem"></a>B. Stone Age Problem</h1><ul>
<li>操作 1 ：指定第 i 个数变为 a。</li>
<li>操作 2 ：所有数变为 b。</li>
</ul>
<p>每次变化后都要输出当前数组的和的值。</p>
<p>每次操作 2 时，sum 值是能直接求解的，因此直接输出。同时定义一个基值base，即下一次修改到来前，每个位置的数的值都该是本值；定义一个操作次数 changenum 用来记录这是第几次操作 2 ，再开一个 change 数组代表这个数是经历了第几次操作 2 后的值，为了配合进行操作 1 。</p>
<p>每次操作 1 时，先利用 change 数组确定本数的值是否正确。设本数值为 x ，编号为 i ，若正确，则 sum 值增加 (a - x) ；若不正确，则说明本数的值应为当前的基值 base ，则 sum 值增加 (a - base) ，同时 change[i] &#x3D; changenum ，表示当前值已经经历过最新的 基值 base 的更新了。 最后记得更新本数的值 x。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">int</span> n,p;</span><br><span class="line"><span class="type">int</span> a[<span class="number">200010</span>],change[<span class="number">200010</span>];</span><br><span class="line"><span class="type">int</span> changenum=<span class="number">0</span>,nowbase;</span><br><span class="line">ll nowans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y,z;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;p);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">		nowans+=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">1</span>;v&lt;=p;v++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">		<span class="keyword">if</span>(x==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;y,&amp;z);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(change[y]==changenum)</span><br><span class="line">			&#123;</span><br><span class="line">				nowans+=(z-a[y]);</span><br><span class="line">				a[y]=z;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				nowans+=(z-nowbase);</span><br><span class="line">				a[y]=z;</span><br><span class="line">				change[y]=changenum;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(x==<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;y);</span><br><span class="line">			changenum++;</span><br><span class="line">			nowans=(ll)y*n;</span><br><span class="line">			nowbase=y;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,nowans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-Rooks-Defenders"><a href="#C-Rooks-Defenders" class="headerlink" title="C. Rooks Defenders"></a>C. Rooks Defenders</h1><p>若想让检测区域都被攻击，则检测区域每行上有至少一辆车或每列上至少有一辆车。</p>
<p>开两个数组 row 、 col 分别记录某行和某列上有几辆车。为了提高效率，开两个树状数组 bit1 、 bit2 分别记录某行和某列上有没有车。</p>
<ul>
<li><p>操作 1 ：在 (x, y) 处加一辆车。</p>
<p>row[x]++, col[y]++ ；若这次是本行或本列从无车到有车，在 bit1 或 bit2 上更新为 1 。</p>
</li>
<li><p>操作 2 ：在 (x, y) 处去一辆车。</p>
<p>row[x]–, col[y]– ；若这次是本行或本列从有车到无车，在 bit1 或 bit2 上更新为 0 。</p>
</li>
<li><p>操作 3 ：检测 (x1, y1) 到 (x2, y2) 区域是否全被攻击。</p>
<p>对  x1 到 x2 有无车的树状数组求和，对 y1 到 y2 有无车的树状数组求和，若任意一组和其长度相等，说明这些行或列都有车，输出 Yes ；反之输出 No 。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">int</span> n,p;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> bit1[<span class="number">200010</span>],bit2[<span class="number">200010</span>];</span><br><span class="line"><span class="type">int</span> row[<span class="number">200010</span>],col[<span class="number">200010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(x&lt;=n)</span><br><span class="line">	&#123;</span><br><span class="line">		bit1[x]+=k;</span><br><span class="line">		x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum1</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ans+=bit1[x];</span><br><span class="line">		x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(x&lt;=n)</span><br><span class="line">	&#123;</span><br><span class="line">		bit2[x]+=k;</span><br><span class="line">		x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum2</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ans+=bit2[x];</span><br><span class="line">		x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x,a,b,c,d;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;p);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">1</span>;v&lt;=p;v++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(x==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">			</span><br><span class="line">			row[a]++;</span><br><span class="line">			<span class="keyword">if</span>(row[a]==<span class="number">1</span>) <span class="built_in">add1</span>(a,<span class="number">1</span>);</span><br><span class="line">			</span><br><span class="line">			col[b]++;</span><br><span class="line">			<span class="keyword">if</span>(col[b]==<span class="number">1</span>) <span class="built_in">add2</span>(b,<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(x==<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">			</span><br><span class="line">			row[a]--;</span><br><span class="line">			<span class="keyword">if</span>(!row[a]) <span class="built_in">add1</span>(a,<span class="number">-1</span>);</span><br><span class="line">			</span><br><span class="line">			col[b]--;</span><br><span class="line">			<span class="keyword">if</span>(!col[b]) <span class="built_in">add2</span>(b,<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(x==<span class="number">3</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class="line">			</span><br><span class="line">			<span class="type">int</span> rownum=c-a+<span class="number">1</span>,colnum=d-b+<span class="number">1</span>;</span><br><span class="line">			<span class="type">int</span> nowrownum=<span class="built_in">sum1</span>(c)-<span class="built_in">sum1</span>(a<span class="number">-1</span>);</span><br><span class="line">			<span class="type">int</span> nowcolnum=<span class="built_in">sum2</span>(d)-<span class="built_in">sum2</span>(b<span class="number">-1</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//printf(&quot;%d %d %d %d\n&quot;,rownum,colnum,nowrownum,nowcolnum);</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(rownum==nowrownum||colnum==nowcolnum) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h1><p>上一场比赛因为有不会的题，所以题解慢慢再补……</p>
]]></content>
      <categories>
        <category>算法比赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>O(nlogn)数组寻找差值</title>
    <url>/2022/03/25/O-nlogn-%E6%95%B0%E7%BB%84%E5%AF%BB%E6%89%BE%E5%B7%AE%E5%80%BC/</url>
    <content><![CDATA[<p>设一个长度为$n$的数组$a$，与一个数$k$，问数组中是否存在$2$个数$a$、$b$使得$| a - b | &#x3D; k$。</p>
<ol>
<li>对原数组排序。</li>
<li>对原数组去重得到数组$b$，长度为$len$。</li>
<li>扩充数组$b$至长度为$2 \cdot len$使得$b_{i + len} &#x3D; b_i - k$。</li>
<li>对扩充后的数组排序。</li>
<li>寻找是否有相邻的相同元素。若有，则存在；反之不存在。</li>
</ol>
<p>会有更简单的办法，但我暂时是想出来了这个。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">200010</span>];</span><br><span class="line"><span class="type">int</span> b[<span class="number">400010</span>],len;</span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solv</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++) b[i]=<span class="number">0</span>;</span><br><span class="line">    b[len]=<span class="number">1000000010</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(a[i]!=b[len]) b[++len]=a[i];</span><br><span class="line">    	</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++) b[i+len]=b[i]-k;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(b+<span class="number">1</span>,b+len*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len*<span class="number">2</span><span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">if</span>(b[i]==b[i+<span class="number">1</span>])</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法比赛</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>gcd&amp;lcm（待完善）</title>
    <url>/2022/03/10/gcd-lcm/</url>
    <content><![CDATA[<h1 id="gcd"><a href="#gcd" class="headerlink" title="gcd"></a>gcd</h1><p><strong>辗转相除法（欧几里得）：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="lcm"><a href="#lcm" class="headerlink" title="lcm"></a>lcm</h1><p>$$<br>a \cdot b &#x3D; \gcd(a, b) * lcm(a, b)<br>$$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a/<span class="built_in">gcd</span>(a,b)*b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="一些性质"><a href="#一些性质" class="headerlink" title="一些性质"></a>一些性质</h1><p>设两个数$i &#x3D; p_1^{a_1} * p_2^{a_2} * p_3^{a_3} * … * p_s^{a_s}$，$j &#x3D; p_1^{b_1} * p_2^{b_2} * p_3^{b_3} * … * p_s^{b_s}$，则由算术基本定理（又叫整数惟一分解定理）得到：</p>
<p>$\gcd(i, j) &#x3D; p_1^{\min(a_1, b_1)} * p_2^{\min(a_2, b_2)} * p_3^{\min(a_3, b_3)} * … * p_s^{\min(a_s, b_s)}$</p>
<p>$lcm(i,j) &#x3D; p_1^{\max(a_1, b_1)} * p_2^{\max(a_2, b_2)} * p_3^{\max(a_3,b_3)} * … * p_s^{\max(a_s, b_s)}$</p>
<p>简写一下：</p>
<p>设两个数$i &#x3D; \prod^s_{k &#x3D; 1} p_k^{a_k}$，$j &#x3D; \prod^s_{k &#x3D; 1} p_k^{b_k}$，则由算术基本定理（又叫整数惟一分解定理）得到：</p>
<p>$\gcd(i, j) &#x3D; \prod^s_{k &#x3D; 1} p_k^{\min(a_k, b_k)}$</p>
<p>$lcm(i,j) &#x3D; \prod^s_{k &#x3D; 1} p_k^{\max(a_k, b_k)}$</p>
<p><strong>此性质经常与数的质因数分解一起使用。</strong>一些质因数分解的方法请看我的另一篇文章。</p>
]]></content>
      <categories>
        <category>算法比赛</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>辗转相除法</tag>
        <tag>质因数分解</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/05/11/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>博客美化指南</title>
    <url>/2022/05/15/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="自定义外观"><a href="#自定义外观" class="headerlink" title="自定义外观"></a>自定义外观</h1><p>打开 next 主题配置文件，进行以下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure>

<p>打开根目录下的 source 文件夹，创建文件_data&#x2F;styles.styl。后大部分CSS样式都可在这里面自定义。</p>
<h2 id="添加背景图片"><a href="#添加背景图片" class="headerlink" title="添加背景图片"></a>添加背景图片</h2><p>在 styles.styl 中添加：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加背景图片</span></span><br><span class="line"><span class="selector-tag">body</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="attribute">background</span>: url(../images/background/background3.jpg);	<span class="comment">//本路径是主题文件夹内的images</span></span><br><span class="line">      <span class="attribute">background-size</span>: cover;</span><br><span class="line">      <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">      <span class="attribute">background-attachment</span>: fixed;</span><br><span class="line">      <span class="attribute">background-position</span>: <span class="number">50%</span> <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="更改站板背景颜色"><a href="#更改站板背景颜色" class="headerlink" title="更改站板背景颜色"></a>更改站板背景颜色</h2><p>在 styles.styl 中添加：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.site-brand-container</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">background</span> <span class="built_in">rgb</span>(<span class="number">70</span>, <span class="number">81</span>, <span class="number">120</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改meta与正文间间距"><a href="#修改meta与正文间间距" class="headerlink" title="修改meta与正文间间距"></a>修改meta与正文间间距</h2><p><img src="/2022/05/15/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96%E6%8C%87%E5%8D%97/1.png" alt="img"></p>
<p>在 styles.styl 中添加：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改meta与正文间间距</span></span><br><span class="line"><span class="selector-class">.posts-expand</span> <span class="selector-class">.post-meta</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">3px</span> <span class="number">0</span> <span class="number">35px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为post块上方留白"><a href="#为post块上方留白" class="headerlink" title="为post块上方留白"></a>为post块上方留白</h2><p><img src="/2022/05/15/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96%E6%8C%87%E5%8D%97/2.png" alt="img"></p>
<p>在 styles.styl 中添加：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.post-block</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加透明度"><a href="#添加透明度" class="headerlink" title="添加透明度"></a>添加透明度</h2><p>在 styles.styl 中添加：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">//文章内容的透明度设置</span></span><br><span class="line"><span class="selector-class">.content-wrap</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.95</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//侧边框的透明度设置</span></span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: transparent;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.95</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//菜单栏的透明度设置</span></span><br><span class="line"><span class="selector-class">.header-inner</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: rgba(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.95</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字体修改"><a href="#字体修改" class="headerlink" title="字体修改"></a>字体修改</h2><p>第一种简易的方法是在主题配置文件中进行修改，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Font Settings</span></span><br><span class="line"><span class="comment"># See: https://theme-next.org/docs/theme-settings/#Fonts-Customization</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Find fonts on Google Fonts (https://www.google.com/fonts)</span></span><br><span class="line"><span class="comment"># All fonts set here will have the following styles:</span></span><br><span class="line"><span class="comment">#   light | light italic | normal | normal italic | bold | bold italic</span></span><br><span class="line"><span class="comment"># Be aware that setting too much fonts will cause site running slowly</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># To avoid space between header and sidebar in scheme Pisces / Gemini, Web Safe fonts are recommended for `global` (and `title`):</span></span><br><span class="line"><span class="comment"># Arial | Tahoma | Helvetica | Times New Roman | Courier New | Verdana | Georgia | Palatino | Garamond | Comic Sans MS | Trebuchet MS</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Uri of fonts host, e.g. https://fonts.googleapis.com (Default).</span></span><br><span class="line">  <span class="attr">host:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font options:</span></span><br><span class="line">  <span class="comment"># `external: true` will load this font family from `host` above.</span></span><br><span class="line">  <span class="comment"># `family: Times New Roman`. Without any quotes.</span></span><br><span class="line">  <span class="comment"># `size: x.x`. Use `em` as unit. Default: 1 (16px)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Global font settings used for all elements inside &lt;body&gt;.</span></span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Lato</span></span><br><span class="line">    <span class="attr">size:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for site title (.site-title).</span></span><br><span class="line">  <span class="attr">title:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br><span class="line">    <span class="attr">size:</span> <span class="number">1.5</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for headlines (&lt;h1&gt; to &lt;h6&gt;).</span></span><br><span class="line">  <span class="attr">headings:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br><span class="line">    <span class="attr">size:</span> <span class="number">1.5</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for posts (.post-body).</span></span><br><span class="line">  <span class="attr">posts:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">微软雅黑</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for &lt;code&gt; and code blocks.</span></span><br><span class="line">  <span class="attr">codes:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br></pre></td></tr></table></figure>

<p>但有时利用这些还达不到我们想要的效果。因此可以去翻找源码进行更为细致的修改。位置为themes&#x2F;next&#x2F;source&#x2F;css&#x2F;_variables&#x2F;base.styl，在其中修改如下段落：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Font size</span></span><br><span class="line"><span class="variable">$font-size-smallest</span>       = <span class="selector-class">.85em</span>;</span><br><span class="line"><span class="variable">$font-size-smaller</span>        = <span class="selector-class">.875em</span>;</span><br><span class="line"><span class="variable">$font-size-small</span>          = <span class="selector-class">.875em</span>;</span><br><span class="line"><span class="variable">$font-size-medium</span>         = <span class="number">1em</span>;</span><br><span class="line"><span class="variable">$font-size-large</span>          = <span class="number">1em</span>;</span><br><span class="line"><span class="variable">$font-size-larger</span>         = <span class="number">1.25em</span>;</span><br><span class="line"><span class="variable">$font-size-largest</span>        = <span class="number">1.5em</span>;</span><br></pre></td></tr></table></figure>

<p>自己实验着修改就好。</p>
<h2 id="边框圆角"><a href="#边框圆角" class="headerlink" title="边框圆角"></a>边框圆角</h2><p>主题配置文件进行如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="attr">variable:</span> <span class="string">source/_data/variables.styl</span></span><br></pre></td></tr></table></figure>

<p>在 _data 文件夹下添加 variables.styl 文件，添加如下内容：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 圆角设置</span></span><br><span class="line"><span class="variable">$border-radius-inner</span>     = <span class="number">20px</span> <span class="number">20px</span> <span class="number">20px</span> <span class="number">20px</span>;</span><br><span class="line"><span class="variable">$border-radius</span>           = <span class="number">20px</span>;</span><br></pre></td></tr></table></figure>

<h2 id="不显示全文"><a href="#不显示全文" class="headerlink" title="不显示全文"></a>不显示全文</h2><p>修改主题配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">excerpt_description:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>之后在写文章时写 description 即可，只会显示 description 的内容。</p>
<h1 id="添加功能"><a href="#添加功能" class="headerlink" title="添加功能"></a>添加功能</h1><h2 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h2><p>首先安装插件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search</span><br></pre></td></tr></table></figure>

<p>之后更改主题配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="评论功能（基于Valine）"><a href="#评论功能（基于Valine）" class="headerlink" title="评论功能（基于Valine）"></a>评论功能（基于Valine）</h2><h3 id="注册LeanCloud"><a href="#注册LeanCloud" class="headerlink" title="注册LeanCloud"></a>注册LeanCloud</h3><p>因为 Valine 是基于 LeanCloud 系统的，所以先注册 LeanCloud 账号。</p>
<p><a href="https://console.leancloud.cn/login">LeanCloud官网</a></p>
<p>注册完成后，在控制台中创建应用，选择开发版。</p>
<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>首先在 LeanCloud 上获取 AppID 和 AppKey：</p>
<p><img src="/2022/05/15/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96%E6%8C%87%E5%8D%97/3.png" alt="img"></p>
<p>在主题配置文件中进行如下修改：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Valine</span></span><br><span class="line"><span class="comment"># For more information: https://valine.js.org, https://github.com/xCss/Valine</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">appid:</span> <span class="string">填写这里</span> <span class="comment"># Your leancloud application appid</span></span><br><span class="line">  <span class="attr">appkey:</span> <span class="string">填写这里</span> <span class="comment"># Your leancloud application appkey</span></span><br><span class="line">  <span class="attr">notify:</span> <span class="literal">false</span> <span class="comment"># Mail notifier</span></span><br><span class="line">  <span class="attr">verify:</span> <span class="literal">false</span> <span class="comment"># Verification code</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">留下一条友善的评论</span> <span class="comment"># Comment box placeholder</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mm</span> <span class="comment"># Gravatar style</span></span><br><span class="line">  <span class="attr">guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment"># Custom comment header</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">8</span> <span class="comment"># Pagination size</span></span><br><span class="line">  <span class="attr">language:</span> <span class="string">zh-cn</span> <span class="comment"># Language, available values: en, zh-cn</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">false</span> <span class="comment"># Article reading statistic</span></span><br><span class="line">  <span class="attr">comment_count:</span> <span class="literal">false</span> <span class="comment"># If false, comment count will only be displayed in post page, not in home page</span></span><br><span class="line">  <span class="attr">recordIP:</span> <span class="literal">false</span> <span class="comment"># Whether to record the commenter IP</span></span><br><span class="line">  <span class="attr">serverURLs:</span> <span class="comment"># When the custom domain name is enabled, fill it in here (it will be detected automatically by default, no need to fill in)</span></span><br><span class="line">  <span class="comment">#post_meta_order: 0</span></span><br></pre></td></tr></table></figure>

<h3 id="管理评论"><a href="#管理评论" class="headerlink" title="管理评论"></a>管理评论</h3><p>评论在这里进行管理：</p>
<p><img src="/2022/05/15/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96%E6%8C%87%E5%8D%97/4.png" alt="img"></p>
]]></content>
      <categories>
        <category>问题指南</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>博客问题指南</title>
    <url>/2022/05/11/%E5%8D%9A%E5%AE%A2%E9%97%AE%E9%A2%98%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>自己在建站的过程也遇到了很多问题，于是在这里给自己写一篇问题指南。</p>
<p><a href="https://hexo.io/zh-cn/docs">Hexo文档</a></p>
<p>首先要记住的一点就是，优先在官方文档找解决方案。</p>
<h1 id="如何开启本地服务器"><a href="#如何开启本地服务器" class="headerlink" title="如何开启本地服务器"></a>如何开启本地服务器</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s          #hexo server，默认端口4000</span><br><span class="line">hexo s -p 1234	#我的本地4000端口似乎被占用，所以要手动换一个端口</span><br></pre></td></tr></table></figure>

<h1 id="如何同步文件"><a href="#如何同步文件" class="headerlink" title="如何同步文件"></a>如何同步文件</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean   #清除缓存文件 db.json 和已生成的静态文件 public</span><br><span class="line">hexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span><br><span class="line">hexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span><br></pre></td></tr></table></figure>

<h1 id="如何支持数学函数"><a href="#如何支持数学函数" class="headerlink" title="如何支持数学函数"></a>如何支持数学函数</h1><p>我采用的方法是使用 next 主题自带的方式。</p>
<p>打开 next 的 _config.yml，设置 mathjax 为 true ：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>之后，在每篇博客前加入 mathjax: true 即可正常显示数学函数了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 博客问题指南</span><br><span class="line">date: 2022-05-11 10:07:20</span><br><span class="line">tags:</span><br><span class="line">mathjax: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h1 id="如何支持-md-语法显示图片"><a href="#如何支持-md-语法显示图片" class="headerlink" title="如何支持 md 语法显示图片"></a>如何支持 md 语法显示图片</h1><p>网上给出了诸多解决办法，但我使用了他们的方法后均没有成功，反而把博客搞崩了一次：（。最后我在官方文档里找到了适合我的解决方法，在此复述一遍。</p>
<p><a href="https://hexo.io/zh-cn/docs/asset-folders">Hexo资源文件夹</a></p>
<p>首先对 hexo 的 _config.yml 进行如下修改：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>修改后每当进行 new post 时，将会自动生成一个同名文件夹。我们要把需使用的图片放入此文件夹。</p>
<p>之后安装 hexo-renderer-marked 插件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-marked --save</span><br></pre></td></tr></table></figure>

<p>安装完成后，在 hexo 的 _config.yml 中添加如下语句：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">postAsset:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>此时，我们就已经可以使用 <code>![](image.jpg)</code> 来引用图片了。</p>
<h1 id="添加标签产生-Cannot-GET-tags-等问题"><a href="#添加标签产生-Cannot-GET-tags-等问题" class="headerlink" title="添加标签产生 Cannot GET \tags\ 等问题"></a>添加标签产生 Cannot GET \tags\ 等问题</h1><p><img src="/2022/05/11/%E5%8D%9A%E5%AE%A2%E9%97%AE%E9%A2%98%E6%8C%87%E5%8D%97/1.png" alt="img"></p>
<p>在 next 的 _config.yml中取消了 tags 的注释，后产生了此错误。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br></pre></td></tr></table></figure>

<p>原因是还需要进行后续的配置。首先创建新的 page：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;tags&quot;</span><br></pre></td></tr></table></figure>

<p>此时 source 文件夹下会新建 tags 文件夹，其下还会产生 index.md 文件，对其进行如下修改：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">标签</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2022-05-11 16:15:22</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;tags&quot;</span>	<span class="comment">#写入本句，这句话的作用似乎是用来识别这个页面是&quot;tags&quot;预置页面</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<p>在这之后，我们就可以愉快的为文章添加标签了，格式如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">博客问题指南</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2022-05-11 10:07:20</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">&quot;博客&quot;</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">&quot;其他&quot;</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">&quot;另一个&quot;</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">true</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<p>其余几项如关于（about）、分类（categories）等同理。</p>
<p><a href="https://www.icode9.com/content-4-1119485.html">参考</a></p>
]]></content>
      <categories>
        <category>问题指南</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈论</title>
    <url>/2022/02/12/%E5%8D%9A%E5%BC%88%E8%AE%BA/</url>
    <content><![CDATA[<p>博弈论就是指有若干个人进行一些对弈，并且默认每个人都可以找到当前的最优解，最后寻找有没有哪个人有必胜&#x2F;必败的的策略。</p>
<h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><p><strong>移动（Move）</strong>：对游戏局面的改变。<br><strong>局面（Position）</strong>：游戏进行中的一种状态。每个局面都对应着一个当前合法操作的集合。<br>​<strong>必败态（P-Position）</strong>：在当前的局面下，先手必败<br>​<strong>必胜态（N-Position）</strong>：在当前的局面下，先手必胜</p>
<p><strong>有关局面的性质：</strong></p>
<ul>
<li>合法操作集合为空的局面是必败态</li>
<li>可以移动到必败态的局面是必胜态</li>
<li>只能移动到必胜态的局面是必败态</li>
</ul>
<h1 id="公平组合游戏（ICG）"><a href="#公平组合游戏（ICG）" class="headerlink" title="公平组合游戏（ICG）"></a>公平组合游戏（ICG）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>两名选手</li>
<li>两名选手轮流行动，每一次行动可以在有限合法操作集合中选择一个</li>
<li>游戏的任何一种可能的局面，合法操作集合只取决于这个局面本身，不取决于轮到哪名选手操作、以前的任何操作、骰子的点数或者其它因素</li>
<li>如果轮到某名选手移动，且这个局面的合法的移动集合为空（也就是说此时无法进行移动），则这名选手负</li>
</ul>
<h2 id="nim游戏"><a href="#nim游戏" class="headerlink" title="nim游戏"></a>nim游戏</h2><p><a href="https://www.luogu.com.cn/problem/P2197">nim游戏</a></p>
<p><strong>题目大意</strong>：有n堆石子，每堆有$s_i$个，两人依次从中任意一堆中取至少1个的任意数量的石子，问先手有没有必胜策略。</p>
<p><strong>在本游戏中可以得到一个结论：</strong><br>$$<br>当且仅当s_1 \oplus s_2 \oplus s_3 \oplus \cdots \oplus s_n &#x3D; 0时，局面为必败态<br>$$<br><strong>证明：</strong></p>
<ul>
<li>当石子数量和为0时为必败态（此时异或和为0）</li>
<li>当各石子堆异或和为$k(k \neq 0)$时，设k的最高位二进制1的位数为j，则我们一定能找到一堆石子$s_i$，且$s_i$的二进制第j位为1。将$s_i$的数量变为$s_i \oplus k$（显然在第j位为1的前提下$s_i &gt; s_i \oplus k$），此时各石子堆异或和便为0了（$x \oplus y \oplus y &#x3D; x$）。（必胜态转必败态）</li>
<li>若异或和为0且存在数量不为0的石子堆，不能找到一种方法使异或和仍为0。（异或的性质）（必败态转必胜态）</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">1</span>;v&lt;=t;v++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> ans,lin;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;ans);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;lin);</span><br><span class="line">			ans^=lin;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(ans) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SG函数"><a href="#SG函数" class="headerlink" title="SG函数"></a>SG函数</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>给定一个有向无环图和一个起始顶点上的一枚棋子，Alice和Bob交替的将这枚棋子沿有向边进行移动，无法移动者判负。问是否有必胜策略。</p>
<p>该游戏可以认为是所有ICG游戏的抽象模型。也就是说，任何一个ICG游戏都可以通过把每个局面看成一个顶点，对每个局面和它的子局面连一条有向边来抽象成这个“有向图游戏”。</p>
<h3 id="函数建立"><a href="#函数建立" class="headerlink" title="函数建立"></a>函数建立</h3><p><strong>mex运算</strong>：这是施加于一个集合的运算，表示最小的不属于这个集合的非负整数，如mex{0, 1, 2, 4} &#x3D; 3、mex{2, 3, 5} &#x3D; 0、mex{} &#x3D; 0。</p>
<p>对于一个给定的有向无环图，定义关于图的每个顶点的SG函数sg如下：sg(x) &#x3D; mex{sg(y) | y是x的后继 }。也就是说，一个点的SG函数为在它所有后继中都未出现的最小的值。</p>
<p><strong>注意</strong>：由于这是一种类似递归的定义，所以对于一张有向无环图，每个点的SG值都是会被直接计算出来的。</p>
<h3 id="函数性质"><a href="#函数性质" class="headerlink" title="函数性质"></a>函数性质</h3><ul>
<li>没有出边的点，SG值为0。</li>
<li>对于一个$sg(x) &#x3D; 0$的顶点x，它的后继y都满足$sg(y) \neq 0$。</li>
<li>对于一个$sg(x) \neq 0$的顶点x，必定存在一个后继y都满足$sg(y) &#x3D; 0$。</li>
</ul>
<p>可以发现，SG函数的性质与必败态、必胜态的性质十分相似：</p>
<ul>
<li>顶点x所代表的局面是必败态当且仅当$sg(x) &#x3D; 0$。</li>
<li>顶点x所代表的局面是必胜态当且仅当$sg(x) &gt; 0$。</li>
</ul>
<h3 id="SG值的阶"><a href="#SG值的阶" class="headerlink" title="SG值的阶"></a>SG值的阶</h3><p>当$sg(x) &#x3D; k$时，表明对于任意一个$0 \leq i &lt; k$，都存在x的一个后继y满足$sg(y) &#x3D; i$。</p>
<p>因此当$sg(x) &#x3D; k$时，我们可以把这个点的SG值称为k阶SG值，它一定可以通过移动转换到一个拥有更低阶SG值的点。</p>
<h2 id="nim游戏与SG函数的联系"><a href="#nim游戏与SG函数的联系" class="headerlink" title="nim游戏与SG函数的联系"></a>nim游戏与SG函数的联系</h2><p>设有$G_1,G_2,G_3, \cdots ,G_n$个有向图游戏，定义游戏$G &#x3D; G_1 + G_2 + G_3 + \cdots + G_n$（游戏本身的加和，不是数学意义上的加和），移动规则为任选一个有向图$G_i$并移动上面的棋子。</p>
<p>Sprague-Grundy定理就是：<br>$$<br>\begin{aligned}<br>    &amp; 对于任意G &#x3D; G_1 + G_2 + G_3 + \cdots + G_n \\<br>    &amp; 有sg(G) &#x3D; sg(G_1) \oplus sg(G_2) \oplus \cdots \oplus sg(G_n) \\<br>    &amp; SG值相同局面，可以认为局面本质相同<br>\end{aligned}<br>$$<br>也就是说，游戏的和的SG函数值是它所有子游戏的SG函数值的异或。</p>
<p>之后我们可以发现，若将nim游戏中的每一堆石头看成一个有向图游戏，则nim游戏是一个符合上述定义的多个有向图相加的游戏G。因此我们可以分别计算每一堆石头的有向图所对应的SG值，再将所有的SG值进行异或从而得到nim游戏的SG值，从而找到必胜策略。</p>
<p><strong>注</strong>：对于任意一张子图$G_i$，它上面的不同的点要理解成本堆石头的当前状态，而不是整个nim游戏的当前状态，是多堆石头的不同状态得到的SG值异或得到了整个nim游戏的SG值，不存在一张有向图代表整个nim游戏（虽然的确可以存在这样一张有向图），而是nim游戏本身就是许多有向图的加和。这是我一开始不理解这个联系的重要一点。</p>
<p>不妨设第i个有向图游戏的点的值为$s_i$，当且仅当本点与本石子堆还剩$s_i$个石子的状态对应。</p>
<p>因此还剩一个问题：对于nim游戏来说，由于直接异或每堆石子的数量即可得到答案，因此：<br>$$<br>\begin{aligned}<br>    &amp; sg(G) &#x3D; s_1 \oplus s_2 \oplus s_3 \oplus \cdots \oplus s_n \\<br>    &amp; sg(G) &#x3D; sg(s_1) \oplus sg(s_2) \oplus \cdots \oplus sg(s_n) \\<br>\end{aligned}<br>$$<br>我们可以得到一个结论：$sg(s_i) &#x3D; s_i$。那么为什么？</p>
<p>这里不做严格证明，不过不难想象，这与SG值阶的转换有关。在标准的nim游戏中，<strong>对于每一堆石子我们每次都可以取任意数量的石子</strong>，由于石子的所有可能数量与有向图上的点一一对应，因此这句话与<strong>本点的SG值可以转换为任意SG值更低阶的点</strong>相对应，也便是<strong>本点的后继是所有小于本点值的点的集合</strong>，因此：<br>$$<br>sg(s_i) &#x3D; mex { x | 0 \leq x &lt; s_i 且x为非负整数 } &#x3D; s_i<br>$$<br>至此，nim游戏与SG函数的联系论述完成。</p>
<h2 id="nim游戏的变形与SG值的计算方法"><a href="#nim游戏的变形与SG值的计算方法" class="headerlink" title="nim游戏的变形与SG值的计算方法"></a>nim游戏的变形与SG值的计算方法</h2><p>在标准的nim游戏中，我们每次可以取不少于1个的任意个石子，使得在转换中有$sg(s_i) &#x3D; s_i$。但大多的时候转换的规律不会这么简单。</p>
<p><strong>第一个例子：</strong></p>
<p><img src="/2022/02/12/%E5%8D%9A%E5%BC%88%E8%AE%BA/2.png" alt="img"></p>
<p><img src="/2022/02/12/%E5%8D%9A%E5%BC%88%E8%AE%BA/3.png" alt="img"></p>
<p><strong>第二个例子：</strong></p>
<p>有n个石子，每次只能取{1, 3, 4}个石子，先取完石子者胜利，那么各个数的SG值为多少？</p>
<p><img src="/2022/02/12/%E5%8D%9A%E5%BC%88%E8%AE%BA/1.png" alt="img"></p>
<p>sg[0]&#x3D;0，f[]&#x3D;{1,3,4}；</p>
<p>x&#x3D;1时，可以取走1-f{1}个石子，剩余{0}个，mex{sg[0]}&#x3D;{0}，故sg[1]&#x3D;1；</p>
<p>x&#x3D;2时，可以取走2-f{1}个石子，剩余{1}个，mex{sg[1]}&#x3D;{1}，故sg[2]&#x3D;0；</p>
<p>x&#x3D;3时，可以取走3-f{1,3}个石子，剩余{2,0}个，mex{sg[2],sg[0]}&#x3D;{0,0}，故sg[3]&#x3D;1；</p>
<p>x&#x3D;4时，可以取走4-f{1,3,4}个石子，剩余{3,1,0}个，mex{sg[3],sg[1],sg[0]}&#x3D;{1,1,0},故sg[4]&#x3D;2；</p>
<p>x&#x3D;5时，可以取走5-f{1,3,4}个石子，剩余{4,2,1}个，mex{sg[4],sg[2],sg[1]}&#x3D;{2,0,1},故sg[5]&#x3D;3；</p>
<p>以此类推…</p>
<table>
<thead>
<tr>
<th align="center">x</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">…</th>
</tr>
</thead>
<tbody><tr>
<td align="center">sg[x]</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">…</td>
</tr>
</tbody></table>
<p>由此我们可以得到一些规律，总结出<strong>SG值的计算方法</strong>：</p>
<ul>
<li>可选步数为任意步，SG(x) &#x3D; x。</li>
<li>可选步数为1~m的连续整数，SG(x) &#x3D; x % (m+1)。</li>
<li>可选步数为一系列不连续的数，用模板计算。</li>
</ul>
<p><strong>模板</strong> 两种方法我觉得都是搜索</p>
<p>方法一：打表 f[]可以取走的石子个数,注意f[]需要从小到大排序 sg[]SG函数值；vis[]标记数组，用于求mex{}</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> f[MAXN],sg[MAXN];</span><br><span class="line"><span class="type">bool</span> vis[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getSG</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">sort</span>(f+<span class="number">1</span>,f+<span class="number">1</span>+n);</span><br><span class="line">	<span class="built_in">memset</span>(sg,<span class="number">0</span>,<span class="built_in">sizeof</span>(sg));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; f[j]&lt;=i; j++)<span class="comment">//f排序是为了让每一种取法都循环到</span></span><br><span class="line">			vis[sg[i-f[j]]]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;=n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (vis[j]==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				sg[i]=j; <span class="keyword">break</span>;</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：dfs s数组是定义特殊取法规则的数组，注意要按照从小到大排序；n表示集合大小 SG函数要初始化为-1，每个集合只需初始化一遍</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> s[MAXN],sg[MAXN],n;</span><br><span class="line"><span class="type">bool</span> vis[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SG_dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (sh[x]!=<span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> sg[x];</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (x&gt;=s[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">SG_dfs</span>(x-s[i]);</span><br><span class="line">			vis[sg[x-s[i]]]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!vis[i])</span><br><span class="line">			<span class="keyword">return</span> sg[x]=i;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.luogu.com.cn/problem/solution/P2197">https://www.luogu.com.cn/problem/solution/P2197</a></p>
<p><a href="https://blog.csdn.net/amf12345/article/details/97934508">https://blog.csdn.net/amf12345/article/details/97934508</a></p>
<p><a href="https://baike.baidu.com/item/SG%E5%87%BD%E6%95%B0/1004609?fr=aladdin">https://baike.baidu.com/item/SG%E5%87%BD%E6%95%B0/1004609?fr=aladdin</a></p>
]]></content>
      <categories>
        <category>算法比赛</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
        <tag>最优解</tag>
      </tags>
  </entry>
  <entry>
    <title>常忘数学公式语法</title>
    <url>/2022/05/15/%E5%B8%B8%E5%BF%98%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>平时写数学公式时，总是忘记一些符号的代码，在此将他们统一记录一下，方便查找。</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">代码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">点乘</td>
<td align="center">\cdot</td>
</tr>
<tr>
<td align="center">约等号</td>
<td align="center">\approx</td>
</tr>
<tr>
<td align="center">累加</td>
<td align="center">\sum</td>
</tr>
<tr>
<td align="center">累乘</td>
<td align="center">\prod</td>
</tr>
<tr>
<td align="center">分式</td>
<td align="center">\over</td>
</tr>
<tr>
<td align="center">小于等于</td>
<td align="center">\leq</td>
</tr>
<tr>
<td align="center">大于等于</td>
<td align="center">\geq</td>
</tr>
<tr>
<td align="center">阿尔法</td>
<td align="center">\alpha</td>
</tr>
<tr>
<td align="center">贝塔</td>
<td align="center">\beta</td>
</tr>
<tr>
<td align="center">空格</td>
<td align="center">\</td>
</tr>
<tr>
<td align="center">回车</td>
<td align="center">\\</td>
</tr>
<tr>
<td align="center">长空格</td>
<td align="center">\quad</td>
</tr>
<tr>
<td align="center">多行对齐</td>
<td align="center">begin{aligned} end{aligned}</td>
</tr>
<tr>
<td align="center">大括号</td>
<td align="center">begin{case} end{case}</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>问题指南</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>语法</tag>
        <tag>latex</tag>
      </tags>
  </entry>
  <entry>
    <title>层次分析法</title>
    <url>/2022/02/09/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/</url>
    <content><![CDATA[<p>层次分析法（AHP）用来解决评价类问题。</p>
<h1 id="评价类问题"><a href="#评价类问题" class="headerlink" title="评价类问题"></a>评价类问题</h1><p>解决评价类问题，首先要想到以下三个问题：</p>
<ul>
<li>我们评价的目标是什么？</li>
<li>我们为了达到这个目标有哪几种可选的方案？</li>
<li>评价的准则或者说指标是什么（我们根据什么东西来评价好坏）</li>
</ul>
<h1 id="打分法"><a href="#打分法" class="headerlink" title="打分法"></a>打分法</h1><table>
<thead>
<tr>
<th align="center"></th>
<th align="center"><strong>指标权重</strong></th>
<th align="center"><strong>方案1</strong></th>
<th align="center"><strong>方案2</strong></th>
<th align="center"><strong>…</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>指标1</strong></td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center"><strong>指标2</strong></td>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center"><strong>指标3</strong></td>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center"><strong>…</strong></td>
<td align="center">1</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">5</td>
</tr>
</tbody></table>
<p>同数字格相加为1。</p>
<h1 id="分治思想"><a href="#分治思想" class="headerlink" title="分治思想"></a>分治思想</h1><p>一次性考虑多个指标间的关系往往考虑不周，因此两两指标进行比较，最终推算出总权重。</p>
<h1 id="重要程度（或满意度）"><a href="#重要程度（或满意度）" class="headerlink" title="重要程度（或满意度）"></a>重要程度（或满意度）</h1><table>
<thead>
<tr>
<th>标度</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>两个因素相比，同样重要</td>
</tr>
<tr>
<td>3</td>
<td>两个因素相比，一个比另一个稍微重要</td>
</tr>
<tr>
<td>5</td>
<td>两个因素相比，一个比另一个明显重要</td>
</tr>
<tr>
<td>7</td>
<td>两个因素相比，一个比另一个强烈重要</td>
</tr>
<tr>
<td>9</td>
<td>两个因素相比，一个比另一个极端重要</td>
</tr>
<tr>
<td>2，4，6，8</td>
<td>上述两相邻判断的中值</td>
</tr>
<tr>
<td>倒数</td>
<td>若A和B比标度是3，则B和A比标度是1&#x2F;3</td>
</tr>
</tbody></table>
<h1 id="判断矩阵"><a href="#判断矩阵" class="headerlink" title="判断矩阵"></a>判断矩阵</h1><table>
<thead>
<tr>
<th align="center"></th>
<th align="center"><strong>指标1</strong></th>
<th align="center"><strong>指标2</strong></th>
<th align="center"><strong>指标3</strong></th>
<th align="center"><strong>指标4</strong></th>
<th align="center"><strong>指标5</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>指标1</strong></td>
<td align="center"><strong>1</strong></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>指标2</strong></td>
<td align="center"></td>
<td align="center"><strong>1</strong></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>指标3</strong></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><strong>1</strong></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>指标4</strong></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><strong>1</strong></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>指标5</strong></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><strong>1</strong></td>
</tr>
</tbody></table>
<p>方案矩阵同理。</p>
<p><strong>注：</strong>指标矩阵由专家填写，方案矩阵由主角填写，判断矩阵在填写后可能有逻辑错误。</p>
<p>填好的5X5方阵记为A，其对应元素为$a_{ij}$，A有如下特点：</p>
<ul>
<li>$a_{ij}$的意义为与指标j相比，i的重要程度。</li>
<li>当$i&#x3D;j$时，两指标相同，记为1。</li>
<li>$a_{ij}&gt;0$且满足$a_{ij} \cdot a_{ji} &#x3D; 1$（正互反矩阵）</li>
</ul>
<h1 id="一致矩阵"><a href="#一致矩阵" class="headerlink" title="一致矩阵"></a>一致矩阵</h1><p>$$<br>\begin{aligned}<br>    &amp; a_{ij} &#x3D; {i的重要程度 \over j的重要程度} , a_{jk} &#x3D; {j的重要程度 \over k的重要程度} \<br>    &amp; a_{ik} &#x3D; {i的重要程度 \over k的重要程度} &#x3D; a_{ij} \cdot a_{jk} \<br>\end{aligned}<br>$$</p>
<p>若正互反矩阵满足$a_{ik} &#x3D; a_{ij} \cdot a_{jk}$，则为一致矩阵。</p>
<p>一致矩阵各行（各列）之间成倍数关系。</p>
<p><strong>注：</strong>因此可知，在使用判断矩阵求权重前，一定要进行<strong>一致性检验</strong>。</p>
<h1 id="一致性检验"><a href="#一致性检验" class="headerlink" title="一致性检验"></a>一致性检验</h1><p><strong>原理：</strong>检验构造的判断矩阵和一致矩阵是否有太大区别。<br>$$<br>\left[<br>    \begin{matrix}<br>        a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \<br>        a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \<br>        \vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>        a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn} \<br>    \end{matrix}<br>\right]<br>为一致矩阵的充要条件：<br>\begin{cases}<br>    a_{ij} &gt; 0 \<br>    a_{11} &#x3D; a_{22} &#x3D; \cdots &#x3D; a_{nn} &#x3D; 1 \<br>    [a_{i1}, a_{i2}, \cdots , a_{in}] &#x3D; k_i[a_{11}, a_{12}, \cdots , a_{1n}]\<br>\end{cases}<br>$$<br>引理：A为n阶方阵，且$r(A) &#x3D; 1$则A有一个特征值为$tr(A)$，其余特征值为0。</p>
<p>因为一致矩阵各行成比例，其秩一定为1。</p>
<p>由引理可知：一致矩阵有一个特征值为n，其余特征值均为0。</p>
<p>另外易得，当特征值为n时，对应的特征向量刚好为$k[{1 \over a_{11}}, {1 \over a_{12}}, \cdots , {1 \over a_{1n}}]^T \ (k \neq 0)$。</p>
<p>引理：n阶正互反矩阵A为一致矩阵当且仅当最大特征值$\lambda_{max} &#x3D; n$，且当正互反矩阵A非一致时一定满足$\lambda_{max} &gt; n$。</p>
<p><strong>步骤：</strong></p>
<p>第一步：计算<strong>一致性指标CI</strong><br>$$<br>CI &#x3D; {\lambda_{max} - n \over n - 1}<br>$$<br>第二步：查找对应的<strong>平均随机一致性指标RI</strong></p>
<table>
<thead>
<tr>
<th><strong>n</strong></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
</tr>
</thead>
<tbody><tr>
<td><strong>RI</strong></td>
<td>0</td>
<td>0</td>
<td>0.52</td>
<td>0.89</td>
<td>1.12</td>
<td>1.26</td>
<td>1.36</td>
<td>1.41</td>
<td>1.46</td>
<td>1.49</td>
<td>1.52</td>
<td>1.54</td>
<td>1.56</td>
<td>1.58</td>
<td>1.59</td>
</tr>
</tbody></table>
<p><strong>注：</strong>在实际应用中，n很少超过10，如果指标的个数大于10，则可考虑建立二级指标体系。</p>
<p>第三步：计算<strong>一致性比例CR</strong><br>$$<br>CR &#x3D; {CI \over RI}<br>$$<br>若$CR &lt; 0.1$，则可认为判断矩阵的一致性可以接受；否则需要对判断矩阵进行修正。</p>
<h1 id="一致矩阵计算权重"><a href="#一致矩阵计算权重" class="headerlink" title="一致矩阵计算权重"></a>一致矩阵计算权重</h1><p>因为各列成比例，所以随便选一列计算权重并进行归一化处理（各项相加等于1）。</p>
<h1 id="判断矩阵计算权重"><a href="#判断矩阵计算权重" class="headerlink" title="判断矩阵计算权重"></a>判断矩阵计算权重</h1><p>因为各列不成比例，所以每列计算权重并进行归一化处理，最后取平均值。</p>
<h2 id="方法1-算术平均法求权重"><a href="#方法1-算术平均法求权重" class="headerlink" title="方法1 算术平均法求权重"></a>方法1 算术平均法求权重</h2><p>第一步：将判断矩阵按照列归一化（每一个元素除以其所在列的和）</p>
<p>第二步：将归一化的各列相加（按行求和）</p>
<p>第三步：将相加后得到的向量中每个元素除以n即可得到权重向量</p>
<p><strong>数学描述：</strong><br>$$<br>\begin{aligned}<br>    &amp; 假设判断矩阵A &#x3D;<br>    \left[<br>    \begin{matrix}<br>        a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \<br>        a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \<br>        \vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>        a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn} \<br>    \end{matrix}<br>\right], \<br>    &amp; 那么算术平均法求得的权重向量 w_i &#x3D; {1 \over n} \sum^n_{j&#x3D;1} {a_{ij} \over \sum^n_{k&#x3D;1} a_{kj}} \ (i &#x3D; 1, 2, \cdots , n)\<br>\end{aligned}<br>$$</p>
<h2 id="方法2-几何平均法求权重"><a href="#方法2-几何平均法求权重" class="headerlink" title="方法2 几何平均法求权重"></a>方法2 几何平均法求权重</h2><p>待补充</p>
<h2 id="方法3-特征值法求权重"><a href="#方法3-特征值法求权重" class="headerlink" title="方法3 特征值法求权重"></a>方法3 特征值法求权重</h2><p>一致矩阵有一个特征值为n，其余特征值均为0。</p>
<p>另外易得，当特征值为n时，对应的特征向量刚好为$k[{1 \over a_{11}}, {1 \over a_{12}}, \cdots , {1 \over a_{1n}}]^T \ (k \neq 0)$。</p>
<p>这一特征向量刚好就是一致矩阵的第一列</p>
<p>还是先归一化。</p>
<p>假如判断矩阵的一致性可以接受，则可仿照一致矩阵求权重的方法。</p>
<p>第一步：求出矩阵A的最大特征值以及其对应的特征向量</p>
<p>第二步：对求出的特征向量进行归一化即得到权重</p>
<h1 id="整体步骤"><a href="#整体步骤" class="headerlink" title="整体步骤"></a>整体步骤</h1><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>分析系统中各因素之间的关系，建议系统的递阶层次结构。</p>
<p>目标层（Objective）</p>
<p>准则层（Criterion）</p>
<p>方案层（Plan）</p>
<h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>对于同一层次的各元素关于上一层次中某一准则的重要性进行两两比较，构造两两比较矩阵（判断矩阵）。</p>
<h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>由判断矩阵计算被比较元素对于该准则的相对权重，并进行一致性检验（检验通过权重才能用）。</p>
<p>三种方法计算权重：</p>
<ul>
<li>算数平均法</li>
<li>几何平均法</li>
<li>特征值法</li>
</ul>
<p>建议三种方法都使用。</p>
<p><strong>CR &gt; 0.1如何修正：</strong></p>
<p>往一致矩阵上调整，一致矩阵各行成倍数关系。</p>
<h2 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h2><p>计算各层元素对系统目标的合成权重，并进行排序。</p>
<h1 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h1><p>（1）评价的决策层不能太多，太多的话n会很大，判断矩阵和一致矩阵差异可能会很大。</p>
<table>
<thead>
<tr>
<th><strong>n</strong></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
</tr>
</thead>
<tbody><tr>
<td><strong>RI</strong></td>
<td>0</td>
<td>0</td>
<td>0.52</td>
<td>0.89</td>
<td>1.12</td>
<td>1.26</td>
<td>1.36</td>
<td>1.41</td>
<td>1.46</td>
<td>1.49</td>
<td>1.52</td>
<td>1.54</td>
<td>1.56</td>
<td>1.58</td>
<td>1.59</td>
</tr>
</tbody></table>
<p>（2）如果决策层中指标的数据是已知的，那么如何利用这些数据来使得评价更加准确？</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 测试数据</span></span><br><span class="line"><span class="comment">% [1 1 4 1/3 3; 1 1 4 1/3 3; 1/4 1/4 1 1/3 1/2; 3 3 3 1 3; 1/3 1/3 2 1/3 1] </span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 输入判断矩阵</span></span><br><span class="line">clear; clc</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;请输入判断矩阵A：&#x27;</span>)</span><br><span class="line">A = input(<span class="string">&#x27;判断矩阵A=&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 方法1：算数平均法求权重</span></span><br><span class="line"><span class="comment">% 第一步：将判断矩阵按照列归一化（每一个元素除以其所在列的和）</span></span><br><span class="line">Sum_A = sum(A)</span><br><span class="line"></span><br><span class="line">[n, n] = <span class="built_in">size</span>(A)	<span class="comment">% 也可以写成n = size(A, 1)</span></span><br><span class="line"><span class="comment">% 因为我们的判断矩阵A是一个方阵，所以这里的r和c相同，我们可以就用同一个字母n表示</span></span><br><span class="line">SUM_A = <span class="built_in">repmat</span>(Sum_A, n, <span class="number">1</span>)	<span class="comment">% repeat matrix的缩写</span></span><br><span class="line"><span class="comment">% 另外一种替代的方法如下：</span></span><br><span class="line"><span class="comment">%	SUM_A = [];</span></span><br><span class="line"><span class="comment">%	for i = 1 : n</span></span><br><span class="line"><span class="comment">%		SUM_A = [SUM_A; Sum_A]</span></span><br><span class="line"><span class="comment">%	end</span></span><br><span class="line">clc; A</span><br><span class="line">SUM_A</span><br><span class="line">Stand_A = A ./ SUM_A</span><br><span class="line"><span class="comment">% 这里我们直接将两个矩阵对应的元素相除即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 第二步：将归一化的各列相加（按行求和）</span></span><br><span class="line">sum(Stand_A, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 第三步：将相加后得到的向量中每个元素除以n即可得到权重向量</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;算术平均法求权重的结果为：&#x27;</span>);</span><br><span class="line"><span class="built_in">disp</span>(sum(Stand_A, <span class="number">2</span>) / n)</span><br><span class="line"><span class="comment">% 首先对标准化后的矩阵按照行求和，得到一个列向量</span></span><br><span class="line"><span class="comment">% 然后再将这个列向量的每个元素同时除以n即可（这里也可用./）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 方法2：几何平均法求权重</span></span><br><span class="line"><span class="comment">% 第一步：将A的元素按照行相乘得到一个新的列向量</span></span><br><span class="line">clc; A</span><br><span class="line">Prduct_A = prod(A, <span class="number">2</span>)</span><br><span class="line"><span class="comment">% prod函数和max函数类似，一个用于乘，一个用于加</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 第二步：将新向量的每个分量开n次方</span></span><br><span class="line">Prduct_n_A = Prduct_A .^ (<span class="number">1</span>/n)</span><br><span class="line"><span class="comment">%这里最每个元素进行乘方操作，开n次方等价于求1/n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 第三步：对该列向量进行归一化即可得到权重向量</span></span><br><span class="line"><span class="comment">% 将这个列向量中的每一个元素除以这一个向量的和即可</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;几何平均法求权重的结果为：&#x27;</span>);</span><br><span class="line"><span class="built_in">disp</span>(Prduct_n_A ./ sum(Prduct_n_A))</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 方法3：特征值法求权重</span></span><br><span class="line"><span class="comment">% 第一步：求出矩阵A的最大特征值以及其对应的特征向量</span></span><br><span class="line">clc</span><br><span class="line">[V, D] = eig(A)	<span class="comment">% V是特征向量，D是由特征值构成的对角矩阵（除了对角元素外都为0）</span></span><br><span class="line">Max_eig = <span class="built_in">max</span>(<span class="built_in">max</span>(D)) <span class="comment">% 也可写成max(D(:))</span></span><br><span class="line"><span class="comment">% 找最大特征值虽在位置用到find函数，其可以返回向量或矩阵中不为0的元素的位置索引。</span></span><br><span class="line"><span class="comment">% 找到最大特征值位置后，需要将包含所有特征值的这个对角矩阵D中，不等于0的位置全变为0</span></span><br><span class="line"><span class="comment">% 此时运用矩阵与常数的大小判断运算</span></span><br><span class="line">D == Max_eig</span><br><span class="line">[r, c] = <span class="built_in">find</span>(D == Max_eig, <span class="number">1</span>)</span><br><span class="line"><span class="comment">%找到D中第一个与最大特征值相等元素的位置，记录其行列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 第二步：对求出的特征向量进行归一化即可得到权重</span></span><br><span class="line">V( : , c)</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;特征值法求权重的结果为：&#x27;</span>);</span><br><span class="line"><span class="built_in">disp</span>(V( : , c) ./ sum(V( : , c)))</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 计算一致性比例CR</span></span><br><span class="line">clc</span><br><span class="line">CI = (Max_eig - n) / (n - <span class="number">1</span>)</span><br><span class="line">RI = [<span class="number">0</span> <span class="number">0</span> <span class="number">0.52</span> <span class="number">0.89</span> <span class="number">1.12</span> <span class="number">1.26</span> <span class="number">1.36</span> <span class="number">1.41</span> <span class="number">1.46</span> <span class="number">1.52</span> <span class="number">1.54</span> <span class="number">1.56</span> <span class="number">1.58</span> <span class="number">1.59</span>];	<span class="comment">% RI最多支持n = 15</span></span><br><span class="line">CR = CI/RI(n);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;一致性指标CI=&#x27;</span>); <span class="built_in">disp</span>(CI);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;一致性比例RI=&#x27;</span>); <span class="built_in">disp</span>(RI);</span><br><span class="line"><span class="keyword">if</span> CR &lt; <span class="number">0.10</span></span><br><span class="line">	<span class="built_in">disp</span>(<span class="string">&#x27;因为CR &lt; 0.10，所以该判断矩阵A的一致性可以接受&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">disp</span>(<span class="string">&#x27;注意：CR &gt;= 0.10，因此该判断矩阵A需要进行修改&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数学建模</category>
      </categories>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2021/03/30/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<p>并查集是一种在线维护集合关系的数据结构，它支持两个操作：</p>
<ul>
<li><strong>合并</strong>：将两个元素所属的集合合并为一个。</li>
<li><strong>查询</strong>：查询某两个元素是否在同一集合中。</li>
</ul>
<p><strong>时间复杂度</strong>：合并与查询都接近$O(1)$。</p>
<h2 id="普通并查集"><a href="#普通并查集" class="headerlink" title="普通并查集"></a>普通并查集</h2><p>假设我们有n个元素，它们分别使用1~n表示。并查集为了实现维护集合关系，为每个元素增加了一个用来指向其他元素的$fa_i$属性（父亲属性）。该属性初始值$fa_i &#x3D; i$（即指向自己）。并查集就是利用了这个父亲属性将不同的元素串连起来，组成不同的集合。</p>
<p>比如有3个元素A、B、C，若我们想要使用fa[A] &#x3D; B的这种关系把它们联系起来形成一个集合，我们可能会这样串连他们（都为向上的有向线段）：</p>
<p><img src="/2021/03/30/%E5%B9%B6%E6%9F%A5%E9%9B%86/1.png" alt="img"></p>
<p>在我们画的图上，我们认为一个点的父亲节点就是该点上方的那个节点，即把图描述出来为：</p>
<ul>
<li>fa[A]&#x3D;B、fa[C]&#x3D;B、fa[B]&#x3D;B</li>
<li>fa[A]&#x3D;B、fa[B]&#x3D;C、fa[C]&#x3D;C</li>
</ul>
<p>由于每个元素都是单指向的，所以我们所能连接出的图的顶部有且只有一个元素（如第一个图为B，第二个图为C）。这个元素的fa为它本身，且集合内的任意元素在沿着fa的指引向上追溯时，一定会找到该元素。所以此元素便是该集合的唯一<strong>标识</strong>，这个向上追溯找到标识的操作便是并查集的核心。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了追溯标识的操作，我们便不难定义出合并与查询：</p>
<p>设x &#x3D; find(A)，y &#x3D; find(B)，即x为A元素所在集合的标识，y为B元素所在集合的标识。</p>
<p><strong>注</strong>：标识本身也是一个元素。在开始时$fa_i &#x3D; i$，也就是说每个元素单独构成一个只有自己的集合。</p>
<ul>
<li><strong>合并</strong>：fa[y] &#x3D; x。将两个元素所属的集合合并为一个。写成fa[x] &#x3D; y效果相同。</li>
<li><strong>查询</strong>：if(x &#x3D;&#x3D; y) 。查询某两个元素是否在同一集合中。</li>
</ul>
<p>看下面这个例子，这是执行了fa[D] &#x3D; B之后集合的样子。</p>
<p><img src="/2021/03/30/%E5%B9%B6%E6%9F%A5%E9%9B%86/2.png" alt="img"></p>
<p>首先我们确认一点，并查集下某个集合的结构就像一棵树，而标识正是这棵树的树根。</p>
<p>我们发现，随着合并次数的增加，树的深度越来越大，如果我们此时查询G所在集合的标识效率会大打折扣。我们可以通过一个小优化来提升效率。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);	<span class="comment">//这里变化了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在递归的过程中压缩了树的高度，向上找到树根后，在逐级下放的过程中将所有子节点的父节点都改变成了树根，使得树被压缩，从而在不影响集合标识的同时提升了find函数的效率，这是并查集的精髓（在带权并查集中会更有体现）。</p>
<p>find(G)后树的压缩情况：</p>
<p><img src="/2021/03/30/%E5%B9%B6%E6%9F%A5%E9%9B%86/3.png" alt="img"></p>
<h2 id="种类并查集"><a href="#种类并查集" class="headerlink" title="种类并查集"></a>种类并查集</h2><p><strong>注</strong>：此部分为本人理解，酌情参考。</p>
<p><a href="https://www.luogu.com.cn/problem/P1525">洛谷P1525 关押罪犯</a></p>
<p><del>看到最小的最大直接二分答案</del></p>
<p>分析一下不难发现，我们需要将罪犯划分为两个集合。</p>
<p>我们可能会使用这种策略：</p>
<ol>
<li>将罪犯组的怨气值由大到小排序，后从大到小依次判断。</li>
<li>若此组可以分开到两个监狱，则分到两个不同的监狱。</li>
<li>若此组不能被分开到两个监狱（1. 这组的两个人因前面的分配已经被分配到同一个监狱里了。2. 有一个相比两人间的仇恨与这两人都有深仇大恨的人已经入狱了），答案为此组怨气值。</li>
</ol>
<p>这个策略是正确的，但若想使用并查集解决便出现了问题。</p>
<p>并查集所支持的操作是将两个集合合并，而不是将两个集合间划分界限。这时，种类并查集孕育而生，它给了并查集更广泛的意义。</p>
<p>现在拓宽集合的概念，我们要为每个集合加上一个<strong>标签</strong>。如一个集合的标签为“它们应该在一起”，同样的，我们可以创造一个标签为“A和B应该分到不同监狱”的集合。当然不难发现这个集合是有限制的，我们定义的标签让我们希望这个集合中只有2个元素。与其说现在在用并查集维护集合，不如说我们现在在用并查集维护一种人与人间的<strong>关系</strong>。</p>
<p>在本题中，由于只有2座监狱，所以存在<strong>传递性</strong>：如果A应与C分开，B也应与C分开，那么A和B就应该在一起。依靠传递性，我们以C为媒介，将A和B间的关系连接了起来。</p>
<p>这时存在一个问题，我们按照这样的关系进行合并：</p>
<ul>
<li>A应与C分开，因此二者放入同一有“A和C应分开”标签的集合，A与C连接</li>
<li>B应与C分开，因此二者放入同一有“B和C应分开”标签的集合，B与C连接</li>
<li>哦吼，A、B、C进入了一个集合，关系混乱了</li>
</ul>
<p>可以看到，使用这种只能存在2个元素的标签虽然想法很美好，但现实很残酷。</p>
<p>为了解决这个问题，我们不仅引入了一种标签，还引入了一种媒介。我们对应每一个罪犯X创建一个<strong>分开媒介!X</strong>，如罪犯C的分开媒介!C。!C存在的目的就是与“不能与C在一起”的罪犯连接起来，形成一个集合，理所当然的，“不能与C在一起”便是这个集合的标签。按照这种理念合并：</p>
<ul>
<li>A应与C分开，因此A应放入“不能与C在一起”的集合，A与!C连接，<strong>同时C应放入“不能与A在一起”的集合，C与!A连接</strong></li>
<li>B应与C分开，因此B应放入“不能与C在一起”的集合，B与!C连接，<strong>同时C应放入“不能与B在一起”的集合，C与!B连接</strong></li>
<li>!C-A-B、!A-C、!B-C，逻辑和结构上很清晰</li>
</ul>
<p><strong>注</strong>：C与!C虽有联系但有本质区别，C是真实存在的罪犯，而!C是一种用来表示“不能与C在一起”的关系的媒介，不过两者在编程过程中被视为同等的元素对待。</p>
<p>题目被解决了，策略如下：</p>
<p>在代码实现中，若有n个罪犯，对应编号分别为$a_i$，那么编号为$a_i$的罪犯的分开媒介的编号使用$a_i + n$表示。</p>
<p>若a、b为一组罪犯的两个编号，设x &#x3D; find(a)，y &#x3D; find(b)，nx &#x3D; find(a + n)，ny &#x3D; find(b + n)。</p>
<ol>
<li>将罪犯组的怨气值由大到小排序，后从大到小依次判断。</li>
<li>如果此组可以分开到两个监狱，则fa[x] &#x3D; ny，fa[y] &#x3D; nx。</li>
<li>如果起了冲突，也就是(x &#x3D;&#x3D; y || nx &#x3D;&#x3D; ny)，输出此组怨气值。</li>
</ol>
<p>再来简略的看一道题：</p>
<p><a href="https://www.luogu.com.cn/problem/P2024">洛谷P2024 食物链</a></p>
<p>对于一类物种，与其他物种应有3种关系：与X同类，被X吃（X的猎物），X被吃（X的猎人）。</p>
<p>假设有n个动物，对应编号分别为$a_i$，那么编号为$a_i$的罪犯的猎物媒介的编号使用$a_i + n$表示，猎人媒介的编号使用$a_i + 2n$表示。</p>
<ul>
<li>当A和B是同类时：分别合并A和B，A的猎物和B的猎物，A的天敌和B的天敌。</li>
<li>当A吃B时：分别合并A和B的天敌，A的猎物和B，<strong>A的猎人和B的猎物</strong>（容易被忽略）。</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li>种类并查集是在维护不同事物间的一种<strong>关系</strong>。</li>
<li>编写时使用多倍长度的数组作为形容多种关系的<strong>媒介</strong>。</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>一个物品与另一个物品存在多个关系，在合并时要考虑所有关系的合并。</li>
<li>不同物品间一定要有连续性，也就是“都与A有同一种关系的东西应该是同一类”。</li>
<li>种类并查集只注重关系，到底哪堆人被分配到了哪个监狱不在考虑范围内。</li>
</ul>
<h2 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h2><p><a href="https://www.luogu.com.cn/problem/P1196">洛谷P1196 银河英雄传说</a></p>
<p>这道题看下来，其中合并和查询的部分使用普通的并查集就可以实现了，问题在于如何求出两个战舰之前的舰数。</p>
<p>不妨这样想，对于每个战舰$a_i$增加一个权值$d_i$用来表示此战舰与本列队头间的舰数，那么战舰$a_i$与$a_j$间的舰数即为$abs(a_i-a_j)-1$，元素带有权值即为带权并查集。现在要考虑的就是如何更新权值。</p>
<p>由于每次移动都是将一列舰队并到另一列的后方，那么对于被移动的那列舰队，所有战舰的$d_i$都应更新加上未移动的舰队的长度。由此发现，我们需要知道每队的长度来维护$d_i$，于是设每队的长度为$s_i$。</p>
<p>设x &#x3D; find(i), y &#x3D; find(j)，每一次移动，都有这样的变化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s[y]+=s[x];</span><br><span class="line">s[x]=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>要注意的是，这里修改的是两个战舰所在集合的长度。现在长度修改好了，还需要的是利用更新过的长度去更新被移动的所有战舰的$d_i$，这是带权并查集的关键所在。怎么变，一个一个变吗？那样的话效率就和爆搜没有区别了。带权并查集利用了find()函数中的路径压缩优化步骤，巧妙的在路径压缩的过程中更新了$d_i$的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(in==<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">	d[x]+=s[y];	<span class="comment">//被移动舰队的标识战舰的di加上了长度</span></span><br><span class="line">	fa[x]=y;	<span class="comment">//合并，注意此时合并完的舰队的标志战舰已经变为了y，即树根</span></span><br><span class="line">	s[y]+=s[x];</span><br><span class="line">	s[x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在一开始时，每列舰队只有1架战舰，因此每列的队头都是标识战舰（标识的意思看普通并查集），且<strong>合并操作不会改变这一规律</strong>。</p>
<p>合并操作完成后，本列舰队的标识战舰为y，同时我们称x战舰为“曾经的标识战舰”易。知$d_y &#x3D; 0$，而$d_x$被加上了$s_y$，由于在这一步操作前x始终为标识战舰，因此可知$d_x &#x3D; s_y$，可以看到整列被移动的舰队中只有它的$d_i$值被修改了。接下来看find()部分：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="type">int</span> root=<span class="built_in">find</span>(fa[x]);	<span class="comment">//首先执行find()的递归操作</span></span><br><span class="line">	d[x]+=d[fa[x]];			<span class="comment">//回溯时距离更新</span></span><br><span class="line">	<span class="keyword">return</span> fa[x]=root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先明确一点，find(x)的操作只会更新x追溯到他的标识战舰的$d_i$的值和这些点的路径。</p>
<p>我们可以想到，被移动的战舰到队头的距离 &#x3D; 该战舰到曾经的标识战舰的距离（即$d_i$） + 曾经的标识战舰到队头的距离（即$d_x$），而在find()函数向上追溯的过程中，一定能够找到曾经的标识战舰（因为存在路径压缩，所以一定是fa[x]），利用他的值更新自己的值。利用这一点，继续推想：假如曾经的标识战舰处于尚未更新的状态（出现这种情况的原因是因为上面所明确的那一点，也就是还尚未更新过），那么曾经的标识战舰向上追溯又一定能找到“曾经的曾经的标识战舰”，从而利用其值更新自己，后原战舰再根据更新好的曾经的标识战舰的值更新自己的值。由此得出，若想得到正确的曾经的标识战舰的$d_x$则必须要先执行递归find(x)，之后在回溯时更新距离。由于路径压缩的的存在，所有的战舰在更新一次$d_i$后父节点会直接指向最新的标志战舰，而$d_y &#x3D; 0$，从而在当前状态下再次寻找同一战舰时不再更新。这便是路径压缩与$d_i$更新的巧妙配合。</p>
<p><img src="/2021/03/30/%E5%B9%B6%E6%9F%A5%E9%9B%86/4.png" alt="img"></p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">int</span> fa[<span class="number">30010</span>];</span><br><span class="line"><span class="type">int</span> size[<span class="number">30010</span>];</span><br><span class="line"><span class="type">int</span> d[<span class="number">30010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="type">int</span> root=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">	d[x]+=d[fa[x]];</span><br><span class="line">	<span class="keyword">return</span> fa[x]=root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> s[<span class="number">2</span>];</span><br><span class="line">	<span class="type">int</span> a,b;</span><br><span class="line">	<span class="type">int</span> dx,dy;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">30000</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		fa[i]=i;</span><br><span class="line">		size[i]=<span class="number">1</span>;</span><br><span class="line">		d[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>,s+<span class="number">1</span>,&amp;a,&amp;b);</span><br><span class="line">		dx=<span class="built_in">find</span>(a);</span><br><span class="line">		dy=<span class="built_in">find</span>(b);</span><br><span class="line">		<span class="keyword">if</span>(s[<span class="number">1</span>]==<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			d[dx]+=size[dy];</span><br><span class="line">			fa[dx]=dy;</span><br><span class="line">			size[dy]+=size[dx];</span><br><span class="line">			size[dx]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(s[<span class="number">1</span>]==<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(dx!=dy) <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">abs</span>(d[a]-d[b])<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.luogu.com.cn/problem/solution/P1525">https://www.luogu.com.cn/problem/solution/P1525</a></p>
<p><a href="https://www.luogu.com.cn/problem/solution/P2024">https://www.luogu.com.cn/problem/solution/P2024</a></p>
<p><a href="https://www.luogu.com.cn/problem/solution/P1196">https://www.luogu.com.cn/problem/solution/P1196</a></p>
]]></content>
      <categories>
        <category>算法比赛</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2022/02/11/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>归并排序（MERGE-SORT）是利用<strong>归并</strong>的思想实现的排序方法，采用了分治策略。</p>
<p>归并排序的效率稳定。</p>
<p><strong>时间复杂度</strong>：$O(nlog_n)$</p>
<h1 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h1><p><strong>分</strong>：将原问题分成一些小的问题。</p>
<p><strong>治</strong>：将分的阶段得到的各答案”修补”在一起。</p>
<p>本算法使用了递归实现分治，理论上迭代也可。</p>
<p><img src="/2022/02/11/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/1.png" alt="img"></p>
<h1 id="合并有序子序列"><a href="#合并有序子序列" class="headerlink" title="合并有序子序列"></a>合并有序子序列</h1><p>合并有序子序列，即<strong>治</strong>的操作。</p>
<p><img src="/2022/02/11/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/2.png" alt="img">、<img src="/2022/02/11/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/3.png" alt="img"></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://www.luogu.com.cn/problem/P1177">模板题点我</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100010</span>];</span><br><span class="line"><span class="type">int</span> temp[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">psort</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> i=l,j=mid+<span class="number">1</span>,k=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid||j&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;=mid&amp;&amp;j&lt;=r)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]&lt;=a[j]) temp[++k]=a[i++];</span><br><span class="line">			<span class="keyword">else</span> temp[++k]=a[j++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i&lt;=mid) temp[++k]=a[i++];</span><br><span class="line">			<span class="keyword">else</span> temp[++k]=a[j++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++) a[i]=temp[++k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">msort</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(r-l&gt;<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">msort</span>(l,mid);</span><br><span class="line">		<span class="built_in">msort</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">psort</span>(l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">msort</span>(<span class="number">1</span>,n);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/chengxiao/p/6194356.html">https://www.cnblogs.com/chengxiao/p/6194356.html</a></p>
]]></content>
      <categories>
        <category>算法比赛</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>数据结构</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>快速幂</title>
    <url>/2022/03/23/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    <content><![CDATA[<p>快速幂是一种让计算机快速算出$a^b$的算法。</p>
<p>时间复杂度$O(\log b)$</p>
<p><strong>原理：</strong></p>
<p>任意一个十进制数都可以写成$\sum 2^i(i为本数二进制下为1的位的位数-1的)$的形式，这是由十进制与二进制间的转换得来的，如$4_{10} &#x3D; 100_{2} &#x3D; 2^2$、$7_{10} &#x3D; 111_{2} &#x3D; 2^2 + 2^1 + 2^0$、$19_{10} &#x3D; 10011_{2} &#x3D; 2^4 + 2^1 + 2^0$。我们将这种变化应用到$b$上，将原式变形：<br>$$<br>a^b &#x3D; a^{\sum 2^i} &#x3D; \prod a^{2^i}(i为b二进制下为1的位的位数-1)<br>$$<br>即对于代码来说，不断的找到$a^{2^i}$的值进行连乘就可以求得答案，因此我们需要一个简单有效的方法递推$a^{2^i}$的值。</p>
<p>当$i &#x3D; 1,2,3,…,n$时，易得到递推$a^{2^{i + 1}} &#x3D; {a^{2^i}}^2$。同时伴随的问题便是，$i$为本数二进制下所有为$1$的位的位数$-1$的数组，显然前面的定义大于这个数组，因此要增加一个判定条件，确定$b$的二进制的$i + 1$位是否为$1$。若是，则进行连乘，反之跳过。</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fpow</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>==<span class="number">1</span>) ans*=a;</span><br><span class="line">		a*=a;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法比赛</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>插值和拟合</title>
    <url>/2022/02/09/%E6%8F%92%E5%80%BC%E5%92%8C%E6%8B%9F%E5%90%88/</url>
    <content><![CDATA[<p>插值和拟合是数学建模中一种基本的数据分析手段。</p>
<p><strong>插值：</strong>已知函数在某区间（域）内若干点处的值，求该函数在该区间（域）内其它点处的值。</p>
<p><strong>拟合：</strong>根据离散数据求数据间近似函数关系。</p>
<p><strong>区别：</strong></p>
<ul>
<li>插值函数过已知点，拟合函数不一定过已知点。</li>
<li>插值主要用于求函数值，拟合主要用于求函数关系，从而进行预测等进一步分析。</li>
</ul>
<p>当然，某些特定问题既可以用插值也可以用拟合。</p>
<h1 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h1><p>已知函数在某区间（域）内若干点处的值，求该函数在该区间（域）内其它点处的值。</p>
<p>常用的有拉格朗日（Lagrange）插值法和牛顿（Newton）插值法。</p>
<h2 id="拉格朗日插值法"><a href="#拉格朗日插值法" class="headerlink" title="拉格朗日插值法"></a>拉格朗日插值法</h2><p>在节点上给出节点基函数，然后做基函数的线性组合，组合系数为节点函数值的一种插值多项式。<br>$$<br>f(x) &#x3D; y_1 f_1(x) + y_2 f_2(x) + y_3 f_3(x)<br>$$</p>
<p>$$<br>f(x) &#x3D; \sum^k_{i&#x3D;0} y \prod {x - x_j \over x_i - x_j}<br>$$</p>
<h2 id="高次插值的Runge（龙格）现象"><a href="#高次插值的Runge（龙格）现象" class="headerlink" title="高次插值的Runge（龙格）现象"></a>高次插值的Runge（龙格）现象</h2><p>插值多项式的次数超过七时，插值多项式会出现严重的震荡现象，称之为Runge现象。</p>
<p>因此，在实际中不应使用七次以上的插值。</p>
<p>避免的常用方法：将插值区间分成若干小区间，在小区间内使用低次（二次，三次）插值，即分段低次插值，如样条函数插值。</p>
<h2 id="Matlab一维插值"><a href="#Matlab一维插值" class="headerlink" title="Matlab一维插值"></a>Matlab一维插值</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">yi = interp1(x, y, xi, <span class="string">&#x27;method&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>x，y为插值点，xi，yi为被插值点和插值结果，四者通常为向量。</p>
<p>‘method’表示插值方法：</p>
<ul>
<li>‘nearest’：最邻近插值</li>
<li>‘linear’：线性插值</li>
<li>‘spline’：三次样条插值</li>
<li>‘cubic’：立方插值</li>
<li>缺省：线性插值</li>
</ul>
<p><strong>例子：</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = <span class="number">0</span> : <span class="number">2</span>: <span class="number">24</span>;</span><br><span class="line">y = [<span class="number">12</span> <span class="number">9</span> <span class="number">9</span> <span class="number">10</span> <span class="number">18</span> <span class="number">24</span> <span class="number">28</span> <span class="number">27</span> <span class="number">25</span> <span class="number">20</span> <span class="number">18</span> <span class="number">15</span> <span class="number">13</span>];</span><br><span class="line">x1 = <span class="number">13</span>;</span><br><span class="line">y1 = interp1(x, y, x1, <span class="string">&#x27;spline&#x27;</span>);</span><br><span class="line">xi = <span class="number">0</span> : <span class="number">1</span>/<span class="number">3600</span> :<span class="number">24</span>;</span><br><span class="line">yi = interp1(x, y, xi, <span class="string">&#x27;spline&#x27;</span>);</span><br><span class="line"><span class="built_in">plot</span>(x, y, <span class="string">&#x27;*&#x27;</span>, xi, yi)</span><br></pre></td></tr></table></figure>

<h2 id="Matlab二维插值"><a href="#Matlab二维插值" class="headerlink" title="Matlab二维插值"></a>Matlab二维插值</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">zi = interp2(x, y, z, xi, yi, <span class="string">&#x27;method&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>x，y，z为插值点，xi，yi为被插值点，zi为输出的插值结果。</p>
<p>x，y为向量，xi，yi为向量或矩阵，z，zi为矩阵。</p>
<p>‘method’表示插值方法：</p>
<ul>
<li>‘nearest’：最邻近插值</li>
<li>‘linear’：双线性插值</li>
<li>‘spline’：双三次样条插值</li>
<li>‘cubic’：双立方插值</li>
<li>缺省：双线性插值</li>
</ul>
<p><strong>例子：</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = <span class="number">1</span> : <span class="number">5</span>;</span><br><span class="line">y = <span class="number">1</span> : <span class="number">3</span>;</span><br><span class="line">temps = [<span class="number">82</span> <span class="number">81</span> <span class="number">80</span> <span class="number">82</span> <span class="number">84</span>; <span class="number">79</span> <span class="number">63</span> <span class="number">61</span> <span class="number">65</span> <span class="number">81</span>; <span class="number">84</span> <span class="number">84</span> <span class="number">82</span> <span class="number">85</span> <span class="number">86</span>];</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line">mesh(x, y, temps);</span><br><span class="line">xi = <span class="number">1</span> : <span class="number">0.2</span> : <span class="number">5</span>;</span><br><span class="line">yi = <span class="number">1</span> : <span class="number">0.2</span> : <span class="number">3</span>;</span><br><span class="line">zi = interp2(x, y, temps, xi, yi&#x27;, <span class="string">&#x27;cubic&#x27;</span>);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line">mesh(xi, yi, zi);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>);</span><br><span class="line">contour(xi, yi, zi, <span class="number">20</span>, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">[<span class="built_in">i</span>, <span class="built_in">j</span>] = <span class="built_in">find</span>(zi == <span class="built_in">min</span>(<span class="built_in">min</span>(zi)));</span><br><span class="line">x = xi(<span class="built_in">j</span>), y = yi(<span class="built_in">i</span>), zmin = zi(<span class="built_in">i</span>, <span class="built_in">j</span>)</span><br><span class="line">[<span class="built_in">i</span>, <span class="built_in">j</span>] = <span class="built_in">find</span>(zi == <span class="built_in">max</span>(<span class="built_in">max</span>(zi)));</span><br><span class="line">x = xi(<span class="built_in">j</span>), y = yi(<span class="built_in">i</span>), zmax = zi(<span class="built_in">i</span>, <span class="built_in">j</span>)</span><br></pre></td></tr></table></figure>

<p>xi为行向量，yi为列向量</p>
<p>plot3（空间曲线），mesh（空间曲面），surf（空间曲面），contour（等高线）是三维作图中的常用命令。</p>
<p>mesh和surf的区别：mesh是曲面网格图，surf是曲面表面图。</p>
<p>contour(x, y, z, n)是做出由点(x, y, z)插值而成曲面的n条等高线。</p>
<p>meshc和surfc可在曲面下方画等高线。</p>
<p>meshz和surfz是画垂帘图。</p>
<p>程序最后部分为求最高（低）点。</p>
<h2 id="Matlab散乱点插值"><a href="#Matlab散乱点插值" class="headerlink" title="Matlab散乱点插值"></a>Matlab散乱点插值</h2><p>前面的插值点(x, y)均为网格点。当点为散乱点时使用本方法进行二维插值。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">griddata(x, y, z, xi, yi, <span class="string">&#x27;method&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>例子：</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = [<span class="number">129</span> <span class="number">140</span> <span class="number">103.5</span> <span class="number">88</span> <span class="number">185.5</span> <span class="number">195</span> <span class="number">105.5</span> <span class="number">157.5</span> <span class="number">107.5</span> <span class="number">77</span> <span class="number">81</span> <span class="number">162</span> <span class="number">162</span> <span class="number">117.5</span>];</span><br><span class="line">y = [<span class="number">7.5</span> <span class="number">141.5</span> <span class="number">23</span> <span class="number">147</span> <span class="number">22.5</span> <span class="number">137.5</span> <span class="number">85.5</span> <span class="number">-6.5</span> <span class="number">-81</span> <span class="number">3</span> <span class="number">56.5</span> <span class="number">-66.5</span> <span class="number">84</span> <span class="number">-33.5</span>];</span><br><span class="line">z = [<span class="number">-4</span> <span class="number">-8</span> <span class="number">-6</span> <span class="number">-8</span> <span class="number">-6</span> <span class="number">-8</span> <span class="number">-8</span> <span class="number">-9</span> <span class="number">-9</span> <span class="number">-8</span> <span class="number">-8</span> <span class="number">-9</span> <span class="number">-4</span> <span class="number">-9</span>];</span><br><span class="line">[xi, yi] = <span class="built_in">meshgrid</span>(<span class="number">75</span> : <span class="number">0.5</span> : <span class="number">200</span>, <span class="number">-70</span> : <span class="number">0.5</span> : <span class="number">150</span>);</span><br><span class="line">zi = griddata(x, y, z, xi, yi, <span class="string">&#x27;cubic&#x27;</span>);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line">meshz(xi, yi, zi);</span><br><span class="line">xlabel(<span class="string">&#x27;X&#x27;</span>), ylabel(<span class="string">&#x27;Y&#x27;</span>), zlabel(<span class="string">&#x27;Z&#x27;</span>);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>), contour(xi, yi, zi, [<span class="number">-5</span> <span class="number">-5</span>], <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">grid;</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(x, y, <span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;X&#x27;</span>), ylabel(<span class="string">&#x27;Y&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h1><p>根据离散数据求数据间近似函数关系。</p>
<h2 id="拟合的计算"><a href="#拟合的计算" class="headerlink" title="拟合的计算"></a>拟合的计算</h2><p>曲线拟合需要解决两个问题：</p>
<ul>
<li>线型的选择</li>
<li>线型中参数的计算</li>
</ul>
<p>线型的选择是拟合计算的关键和难点，通常主要根据专业知识和散点图确定。</p>
<p>线性拟合中参数的计算可采用最小二乘法，非线性拟合中参数的计算要应用Gauss-Newton迭代法。</p>
<h2 id="Matlab多项式拟合"><a href="#Matlab多项式拟合" class="headerlink" title="Matlab多项式拟合"></a>Matlab多项式拟合</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">[a, S] = polyfit(x, y, n)</span><br></pre></td></tr></table></figure>

<p>x，y是被拟合数据的自变量和因变量。</p>
<p>n为拟合多项式次数。</p>
<p>a为那你和多项式系数构成的向量。</p>
<p>S为分析拟合效果所需的指标（可省略）。</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">x</td>
<td>被拟合数据的自变量</td>
</tr>
<tr>
<td align="center">y</td>
<td>被拟合数据的因变量</td>
</tr>
<tr>
<td align="center">n</td>
<td>拟合多项式次数</td>
</tr>
<tr>
<td align="center">a</td>
<td>拟合多项式系数构成的向量</td>
</tr>
<tr>
<td align="center">S</td>
<td>分析拟合效果所需的指标（可省略）</td>
</tr>
</tbody></table>
<p><strong>例子：</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = <span class="number">1</span> : <span class="number">12</span>;</span><br><span class="line">y = [<span class="number">5</span> <span class="number">8</span> <span class="number">9</span> <span class="number">15</span> <span class="number">25</span> <span class="number">29</span> <span class="number">31</span> <span class="number">30</span> <span class="number">22</span> <span class="number">25</span> <span class="number">27</span> <span class="number">24</span>];</span><br><span class="line">a = polyfit(x, y, <span class="number">9</span>)</span><br><span class="line">xp = <span class="number">1</span> : <span class="number">0.1</span> : <span class="number">12</span>;</span><br><span class="line">yp = polyval(a, xp);</span><br><span class="line"><span class="built_in">plot</span>(x, y, <span class="string">&#x27;.k&#x27;</span>, xp, yp, <span class="string">&#x27;r&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Matlab非线性拟合"><a href="#Matlab非线性拟合" class="headerlink" title="Matlab非线性拟合"></a>Matlab非线性拟合</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">[b, r] = polyfit(x, y, fun, b0, option)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">x</td>
<td>被拟合数据的自变量</td>
</tr>
<tr>
<td align="center">y</td>
<td>被拟合数据的因变量</td>
</tr>
<tr>
<td align="center">fun</td>
<td>拟合函数</td>
</tr>
<tr>
<td align="center">b0</td>
<td>拟合函数的初始迭代值</td>
</tr>
<tr>
<td align="center">option</td>
<td>拟合选项</td>
</tr>
<tr>
<td align="center">b</td>
<td>拟合参数</td>
</tr>
<tr>
<td align="center">r</td>
<td>拟合残差</td>
</tr>
</tbody></table>
<p><strong>例子：</strong><br>$$<br>找好的关系式：y &#x3D;A_1 e^{-x \over t_1} +A_2 e^{-x \over t_2} + y_0<br>$$</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = <span class="number">1</span> : <span class="number">16</span>;</span><br><span class="line">y = [<span class="number">4.00</span> <span class="number">6.40</span> <span class="number">8.00</span> <span class="number">8.80</span> <span class="number">9.22</span> <span class="number">9.50</span> <span class="number">9.70</span> <span class="number">9.86</span> <span class="number">10.00</span> <span class="number">10.20</span> <span class="number">10.32</span> <span class="number">10.42</span> <span class="number">10.50</span> <span class="number">10.55</span> <span class="number">10.58</span> <span class="number">10.60</span>];</span><br><span class="line">y1 = @(b, t)b(<span class="number">1</span>) * <span class="built_in">exp</span>(-t / b(<span class="number">2</span>)) + b(<span class="number">3</span>) * <span class="built_in">exp</span>(-t / b(<span class="number">4</span>)) + b(<span class="number">5</span>);</span><br><span class="line">b0 = [<span class="number">-1</span> <span class="number">1</span> <span class="number">-1</span> <span class="number">1</span> <span class="number">0</span>];</span><br><span class="line">a = nlinfit(x, y, y1, b0)</span><br><span class="line">xp = <span class="number">1</span> : <span class="number">0.1</span> : <span class="number">16</span>;</span><br><span class="line">yp = y1(a, xp);</span><br><span class="line"><span class="built_in">plot</span>(x, y, <span class="string">&#x27;.k&#x27;</span>, xp, yp, <span class="string">&#x27;r&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Matlab拟合工具箱"><a href="#Matlab拟合工具箱" class="headerlink" title="Matlab拟合工具箱"></a>Matlab拟合工具箱</h2><p>使用Matlab编程进行拟合不便：</p>
<ul>
<li>需要编程。如匿名函数等。</li>
<li>拟合结果不完整。Matlab拟合命令一般只提供拟合系数等基本结果。若要获取表示拟合优劣的统计量有时需要另外计算。</li>
</ul>
<p>因此使用Matlab拟合工具箱。</p>
<p><strong>工具箱的启动：</strong></p>
<p>在命令窗口键入cftool。</p>
<p><strong>数据的录入：</strong></p>
<p>在命令窗口录入自变量x和函数y的数据，然后再Data菜单中即可选中上述数据，并产生Data sets。</p>
<p>此时工具箱会自动画出散点图。</p>
<p><strong>拟合：</strong></p>
<p>点击Fitting -&gt; New fit，可以修改Fit name，选择Data sets（自动）和Type of Fit。</p>
<p>Apply后即可完成拟合。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Custom Equations</td>
<td>用户自定义的函数类型</td>
</tr>
<tr>
<td align="center">Exponential</td>
<td>指数逼近，2种，a * exp(b * x)、a * exp(b * x) + c * exp(d * x)</td>
</tr>
<tr>
<td align="center">Fourier</td>
<td>傅里叶逼近，7种，基础型是a0 + a1 * cos(x * w) + b1 * sin(x * w)</td>
</tr>
<tr>
<td align="center">Gaussian</td>
<td>高斯逼近，8种，基础型是a1 * exp(-((x - b1) &#x2F; c1)^2)</td>
</tr>
<tr>
<td align="center">Interpolant</td>
<td>插值逼近，4种，linear、nearest neighbor、cubic spline、shape-preserving</td>
</tr>
<tr>
<td align="center">Polynomial</td>
<td>多形式逼近，9种，…</td>
</tr>
<tr>
<td align="center">Power</td>
<td>幂逼近，2种，…</td>
</tr>
<tr>
<td align="center">Rational</td>
<td>有理数逼近，分子分母共有的类型是linear、quadratic、cubic、4-6th degree；此外分子还包括constant型</td>
</tr>
<tr>
<td align="center">Smoothing Spline</td>
<td>平滑逼近（翻译不太恰当）</td>
</tr>
<tr>
<td align="center">un of Sin Functions</td>
<td>正弦曲线逼近，8种，基础型是a1 * sin(b1 * x + c1)</td>
</tr>
<tr>
<td align="center">Weibull</td>
<td>只有一种，a * b * x^(b - 1) * exp(-a * x^b)</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>数学建模</category>
      </categories>
  </entry>
  <entry>
    <title>筛法</title>
    <url>/2020/10/25/%E7%AD%9B%E6%B3%95/</url>
    <content><![CDATA[<p>筛法是一种用来求素数的方法。一般来说可以循序渐进的掌握暴力判断素数、埃氏筛法、欧拉筛法。</p>
<h1 id="暴力判断素数"><a href="#暴力判断素数" class="headerlink" title="暴力判断素数"></a>暴力判断素数</h1><p>时间复杂度$O(n^2)$(对于打出素数表来说)</p>
<p>利用素数只能被$1$和它本身整除的性质，我们可以把需判断的数$x$与$2…n - 1$取余。如果结果均不等于$0$，则为素数。</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"> <span class="number">3</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"> <span class="number">4</span> </span><br><span class="line"> <span class="number">5</span> <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> <span class="number">6</span> </span><br><span class="line"> <span class="number">7</span> <span class="type">int</span> n;</span><br><span class="line"> <span class="number">8</span> <span class="type">bool</span> flag;</span><br><span class="line"> <span class="number">9</span> </span><br><span class="line"><span class="number">10</span> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">11 </span>&#123;</span><br><span class="line"><span class="number">12</span>     <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="number">13</span>     </span><br><span class="line"><span class="number">14</span>     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line"><span class="number">15</span>     &#123;</span><br><span class="line"><span class="number">16</span>         flag=<span class="literal">true</span>;</span><br><span class="line"><span class="number">17</span>         <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=i<span class="number">-1</span>;j++)</span><br><span class="line"><span class="number">18</span>         &#123;</span><br><span class="line"><span class="number">19</span>             <span class="keyword">if</span>(i%j==<span class="number">0</span>)</span><br><span class="line"><span class="number">20</span>             &#123;</span><br><span class="line"><span class="number">21</span>                 flag=<span class="literal">false</span>;</span><br><span class="line"><span class="number">22</span>                 <span class="comment">//当出现第一个能被整除的数时立即跳出循环，可提高一定效率</span></span><br><span class="line"><span class="number">23</span>                 <span class="keyword">break</span>;</span><br><span class="line"><span class="number">24</span>             &#125;</span><br><span class="line"><span class="number">25</span>         &#125;</span><br><span class="line"><span class="number">26</span>         </span><br><span class="line"><span class="number">27</span>         <span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line"><span class="number">28</span>     &#125;</span><br><span class="line"><span class="number">29</span>     </span><br><span class="line"><span class="number">30</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">31</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这个最简单的写法在只判断几个素数时绰绰有余，但是当要打出一个很大的素数表时效率不足。</p>
<h1 id="埃氏筛法"><a href="#埃氏筛法" class="headerlink" title="埃氏筛法"></a>埃氏筛法</h1><p>时间复杂度$O(n \log n)$</p>
<p>任意一个素数的倍数是合数是埃氏筛法筛出素数表的主要原理。假设要打出$n$以内的素数表。我们从$2$开始向后遍历，每当遇到一个素数$p$时，便利用此素数将$2…n$内$p<em>2，p</em>3，p*4…$这些合数全部筛去。</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"> <span class="number">3</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"> <span class="number">4</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"> <span class="number">5</span> </span><br><span class="line"> <span class="number">6</span> <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> <span class="number">7</span> </span><br><span class="line"> <span class="number">8</span> <span class="type">int</span> n;</span><br><span class="line"> <span class="number">9</span> <span class="type">int</span> p[<span class="number">10000010</span>];</span><br><span class="line"><span class="number">10</span> </span><br><span class="line"><span class="number">11</span> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">12 </span>&#123;</span><br><span class="line"><span class="number">13</span>     <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="number">14</span>     </span><br><span class="line"><span class="number">15</span>     <span class="comment">//初始化</span></span><br><span class="line"><span class="number">16</span>     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) p[i]=<span class="number">1</span>;</span><br><span class="line"><span class="number">17</span>     </span><br><span class="line"><span class="number">18</span>     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(n)+<span class="number">0.5</span>;i++)</span><br><span class="line"><span class="number">19</span>         <span class="keyword">for</span>(<span class="type">int</span> j=i*<span class="number">2</span>;j&lt;=n;j+=i) p[j]=<span class="number">0</span>;</span><br><span class="line"><span class="number">20</span>     </span><br><span class="line"><span class="number">21</span>     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line"><span class="number">22</span>         <span class="keyword">if</span>(p[i]) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line"><span class="number">23</span>     </span><br><span class="line"><span class="number">24</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">25</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这个算法在一般的数据面前已经足够了。不过还可以更快。</p>
<h1 id="欧拉筛法"><a href="#欧拉筛法" class="headerlink" title="欧拉筛法"></a>欧拉筛法</h1><p>时间复杂度$O(n)$</p>
<p>首先观察一下埃氏筛法。我们发现有这样一个问题：在使用素数$2$进行筛去操作时，会筛去素数$6$；在之后利用素数$3$进行筛去操作时，会再筛去一次素数$6$。可见在埃氏筛法的筛去过程中，会出现同一个合数被筛去多次的情况，从而影响了效率。</p>
<p>相比之下，欧拉筛法是一种线性筛法。它便解决了埃氏筛法中一个合数会被筛去多次的问题，确保了每一个合数都只会被筛去一次，因此具有$O(n)$的效率。它的实现原理是<strong>确保每个合数都只会被它的最小质因数筛掉</strong>。过程大概如下：</p>
<p>首先我们会建立$2$个数组：$isp$（值为$1&#x2F;0$，$isp[i]$用来表示$i$是否是素数），$p$（用来储存所有的素数）。依旧是打出到$n$的素数表。</p>
<ol>
<li><p>从$2$开始遍历$i$。如果$i$是素数，就把它加入到数组$p$中。</p>
</li>
<li><p>对于每个$i$使用$j$遍历数组$p$，筛去$i * p[j]$，若$i * p[j] &gt; n$（已经没必要筛去了）或$i \mod p[j] &#x3D;&#x3D; 0$（<strong>这是确保每个合数只筛一次的核心</strong>）就退出循环。</p>
</li>
</ol>
<p><strong>对核心的解释：</strong>假设在$i \mod p[j] &#x3D;&#x3D; 0$时我们继续进行，便筛去了合数$i * p[j+1]$。由于此时$i \mod p[j] &#x3D;&#x3D; 0$，则这个由一个素数和一个合数的乘积组成的合数，一定能转化为一个更小的素数和一个更大的合数的乘积，那么当继续运行时，此合数必然还会被$p[j]$再次筛去，便进行了多余的筛去工作。因此可以说在$i \mod p[j] &#x3D;&#x3D; 0$时退出循环是确保每个合数都只会被它的最小质因数筛掉，即确保了每个合数只被筛一次。</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"> <span class="number">3</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"> <span class="number">4</span> </span><br><span class="line"> <span class="number">5</span> <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> <span class="number">6</span> </span><br><span class="line"> <span class="number">7</span> <span class="type">int</span> n;</span><br><span class="line"> <span class="number">8</span> <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line"> <span class="number">9</span> <span class="type">int</span> isp[<span class="number">10000010</span>],p[<span class="number">10000010</span>];</span><br><span class="line"><span class="number">10</span> </span><br><span class="line"><span class="number">11</span> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">12 </span>&#123;</span><br><span class="line"><span class="number">13</span>     <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="number">14</span>     </span><br><span class="line"><span class="number">15</span>     <span class="comment">//初始化</span></span><br><span class="line"><span class="number">16</span>     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) isp[i]=<span class="number">1</span>;</span><br><span class="line"><span class="number">17</span>     </span><br><span class="line"><span class="number">18</span>     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line"><span class="number">19</span>     &#123;</span><br><span class="line"><span class="number">20</span>         <span class="keyword">if</span>(isp[i])</span><br><span class="line"><span class="number">21</span>         &#123;</span><br><span class="line"><span class="number">22</span>             num++;</span><br><span class="line"><span class="number">23</span>             p[num]=i;</span><br><span class="line"><span class="number">24</span>         &#125;</span><br><span class="line"><span class="number">25</span>         <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=num&amp;&amp;i*p[j]&lt;=n;j++)</span><br><span class="line"><span class="number">26</span>         &#123;</span><br><span class="line"><span class="number">27</span>             isp[i*p[j]]=<span class="number">0</span>;</span><br><span class="line"><span class="number">28</span>             <span class="comment">//确保每个合数都只会被它的最小质因数筛掉</span></span><br><span class="line"><span class="number">29</span>             <span class="keyword">if</span>(i%p[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="number">30</span>         &#125;</span><br><span class="line"><span class="number">31</span>     &#125;</span><br><span class="line"><span class="number">32</span>     </span><br><span class="line"><span class="number">33</span>     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p[i]);</span><br><span class="line"><span class="number">34</span>     </span><br><span class="line"><span class="number">35</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">36</span> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法比赛</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流</title>
    <url>/2022/02/11/%E7%BD%91%E7%BB%9C%E6%B5%81/</url>
    <content><![CDATA[<h1 id="相关定义"><a href="#相关定义" class="headerlink" title="相关定义"></a>相关定义</h1><p>首先想象一张有n个点，m条边的有向图。</p>
<p><strong>源点</strong>：只出不进的点。</p>
<p><strong>汇点</strong>：只进不出的点。</p>
<p><strong>容量</strong>：边的属性，通常使用c[i, j]表示。</p>
<p><strong>流量</strong>：边的属性，通常使用f[i, j]表示。</p>
<p>可以把边想象成道路，容量即本路最多能承载的车流量，流量即车流量，显然<strong>流量≤容量</strong>。</p>
<p>可以把不是源点和汇点的点想象成没有储存功能的货物中转站，<strong>进入的流量&#x3D;出去的流量</strong>。</p>
<p><strong>最大流</strong>：若把源点比作工厂，问题就是求从工厂最大发出多少货物同时不超过道路的容量限制，即<strong>最大流</strong>。</p>
<p><strong>可行流</strong>：所有边上的流量都不超过容量的这一组流量（或者说这个流）。</p>
<p><strong>零流</strong>：所有流量都为0的流，易得零流是可行流。</p>
<p><strong>增广路</strong>：一条从源点到汇点的比之前的流大delta的流。（后面解释）</p>
<p><strong>残量网络</strong>：在原图的基础之上，添加每条边对应的反向边，并储存每条边的当前流量。残量网络会在算法进行的过程中被修改。</p>
<h1 id="求解思路"><a href="#求解思路" class="headerlink" title="求解思路"></a>求解思路</h1><ol>
<li>从零流开始考虑。假设存在一条从源点到汇点的路，其每一段都满足流量＜容量（注意不是≤）。</li>
<li>则一定能找到本路上每一段的(容量 - 流量)的<strong>最小值delta</strong>，显然本路上的每一段的流量加上delta仍是可行流。</li>
<li>于是我们得到了一个更大的流，他的流量为其原来的流量+delta，这条路被叫做<strong>增广路</strong>。我们不断地从起点开始寻找增广路，每次都对其进行增广，直到源点和汇点不连通，也就是找不到增广路为止。</li>
<li>当找不到增广路时，当前的流量就是最大流。</li>
</ol>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul>
<li>寻找增广路可以简单的从源点开始做BFS，并不断修改这条路上的delta量，直到找到源点或者找不到增广路。</li>
<li>程序实现时，通常只用一个数组c记录容量，当流量+delta时使用容量-delta实现，从而方便程序实现。（个人认为此时数组c的意义发生了改变，叫做<strong>能容量</strong>，也就是当前状态下能容下的量更为准确，后面也使用本叫法）</li>
</ul>
<h1 id="增加反向边"><a href="#增加反向边" class="headerlink" title="增加反向边"></a>增加反向边</h1><p><strong>为什么增加反向边：</strong>在寻找增广路时不同的寻找顺序可能会导致结果不同，加入反向边使得能够自我调整寻找顺序。</p>
<p><strong>例子：</strong></p>
<p>求本模型最大流。</p>
<p><img src="/2022/02/11/%E7%BD%91%E7%BB%9C%E6%B5%81/1.jpg" alt="img"></p>
<p>找到1-2-3-4这条增广路，delta显然是1，进行修改。</p>
<p><img src="/2022/02/11/%E7%BD%91%E7%BB%9C%E6%B5%81/2.jpg" alt="img"></p>
<p>此时找不到增广路了，当前流量是1。但显然这不是正确答案。</p>
<p>正确答案应该是走1-2-4和1-3-4，得到流量为2的流。</p>
<p>因此可以看到，错误的找增广路顺序使程序得出了错误的答案，应当给程序一个“后悔”改路的机会，于是引入反向边。</p>
<p>反向边初始能容量均为0，每一次找到增广路时，进行如下操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c[i][j]-=delta;	<span class="comment">//正向边减delta</span></span><br><span class="line">c[j][i]+=delta;	<span class="comment">//反向边加delta</span></span><br></pre></td></tr></table></figure>

<p>按此方法重新寻找到增广路1-2-3-4并修改。</p>
<p><img src="/2022/02/11/%E7%BD%91%E7%BB%9C%E6%B5%81/3.jpg" alt="img"></p>
<p>再次寻找增广路，找到1-3-2-4这条，delta为1，将这条路增广后不再有增广路，得到了最大流2。</p>
<p><img src="/2022/02/11/%E7%BD%91%E7%BB%9C%E6%B5%81/4.jpg" alt="img"></p>
<p>可以认为，两次通过的2、3的相反的等大小流相互抵消了，因此1-2-3-4与1-3-2-4这两个流合起来的作用效果也就是1-2-4和1-3-4这两个流加起来的作用效果。</p>
<h1 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h1><p><a href="https://www.luogu.com.cn/problem/P3376">模板题点我</a></p>
<p>听说有dinic和sap（isap），这里只写dinic。</p>
<h2 id="FF"><a href="#FF" class="headerlink" title="FF"></a>FF</h2><p>FF为一种直接深搜找增广路的暴力方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,s,t;</span><br><span class="line"><span class="type">int</span> a[<span class="number">210</span>],tot=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> vis[<span class="number">210</span>];</span><br><span class="line">LL ans=<span class="number">0</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	tot=1是为了更方便的找到反向边。 </span></span><br><span class="line"><span class="comment">	tot=1会使第一条边编号为2（二进制10），第二条边编号为3（二进制11），以此类推。</span></span><br><span class="line"><span class="comment">	又由于在加边时会把相反的两条边依次加入，所以每条边与他的反向边在编号上只在末位差1。</span></span><br><span class="line"><span class="comment">	因此只要将现编号与1异或就可以方便的得到反向边的编号。 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bian</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> to;</span><br><span class="line">	LL w;</span><br><span class="line">	<span class="type">int</span> next;</span><br><span class="line">&#125;e[<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> from,<span class="type">int</span> to,LL w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tot++;</span><br><span class="line">	e[tot].next=a[from];</span><br><span class="line">	a[from]=tot;</span><br><span class="line">	e[tot].to=to;</span><br><span class="line">	e[tot].w=w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,LL delta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(now==t) <span class="keyword">return</span> delta;</span><br><span class="line">	</span><br><span class="line">	vis[now]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v=a[now];v;v=e[v].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> tto=e[v].to;</span><br><span class="line">		LL ww=e[v].w;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(vis[tto]||!ww) <span class="keyword">continue</span>;</span><br><span class="line">		</span><br><span class="line">		LL res=<span class="built_in">dfs</span>(tto,<span class="built_in">min</span>(delta,ww));</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(res)</span><br><span class="line">		&#123;</span><br><span class="line">			e[v].w-=res;</span><br><span class="line">			e[v^<span class="number">1</span>].w+=res; </span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span> res;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LL x,y,z;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;s,&amp;t);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">		<span class="built_in">add</span>(x,y,z);</span><br><span class="line">		<span class="built_in">add</span>(y,x,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	LL lin;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">		lin=<span class="built_in">dfs</span>(s,<span class="number">1e18</span>);</span><br><span class="line">		<span class="keyword">if</span>(lin) ans+=lin;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于每次只找一条路，这条路还可能绕远路，而且增加流量是路上最小的权值，所以效率低。</p>
<p>网上有些题解试图简单卡 FF：</p>
<p><img src="/2022/02/11/%E7%BD%91%E7%BB%9C%E6%B5%81/5.gif" alt="img"></p>
<p>虽然这种图卡不掉FF，但是你可以看出，<strong>FF的复杂度和流量有关</strong>，这很糟糕。</p>
<h2 id="Dinic"><a href="#Dinic" class="headerlink" title="Dinic"></a>Dinic</h2><p>Dinic可解决FF效率低的问题。</p>
<ul>
<li><p>每次多路增广：u 点通过一条边，向 v 输出流量以后，v 会尝试到达汇点（到达汇点才真正增广），然后 v 返回实际增广量。这时，<strong>如果 u 还有没用完的供给，就继续尝试输出到其它边。</strong></p>
<p>但是要警惕绕远路、甚至绕回的情况，不加管制的话极易发生。怎么管？</p>
</li>
<li><p>源点<strong>顺着残量网络</strong>想要到达其它点，需要经过一些边对吧？<strong>按照经过的边数（即源点出发以后的距离）把图分层，即用 bfs 分层。</strong> 每次尝试给予时，<strong>只考虑给予自己下一层的点</strong>，就可以防止混乱。</p>
</li>
<li><p>综合上面两条。每回合也是从源点出发，<strong>先按照当前残量网络分一次层</strong>，随后多路增广，尽可能增加流量。增广过程中，会加入一些反向边，这些反向边逆着层次图，本回合并不会走。所以还需要进入下一回合。一直到 bfs 分层时搜不到汇点（即残量网络断了）为止。</p>
</li>
</ul>
<p>可是它每次只按照 bfs 分层的固定方向进行增广，还能保证正确性吗？这个好理解：只要图中还有增广路（源点顺着残量网络到达汇点的路），<strong>bfs 分层就会搜索到汇点</strong>，于是增广就不会停止，最终也止于没有增广路的局面。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,s,t;</span><br><span class="line"><span class="type">int</span> a[<span class="number">210</span>],tot=<span class="number">1</span>;	<span class="comment">//tot为1和FF同理 </span></span><br><span class="line"><span class="type">int</span> dep[<span class="number">210</span>];</span><br><span class="line">LL ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bian</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> to;</span><br><span class="line">	LL w;</span><br><span class="line">	<span class="type">int</span> next;</span><br><span class="line">&#125;e[<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> from,<span class="type">int</span> to,LL w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tot++;</span><br><span class="line">	e[tot].next=a[from];</span><br><span class="line">	a[from]=tot;</span><br><span class="line">	e[tot].to=to;</span><br><span class="line">	e[tot].w=w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="built_in">sizeof</span>(dep));</span><br><span class="line">	<span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">1</span>,q[<span class="number">210</span>];</span><br><span class="line">	q[l]=s;</span><br><span class="line">	dep[s]=<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> now=q[l++];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> v=a[now];v;v=e[v].next)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> tto=e[v].to,ww=e[v].w;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(ww&amp;&amp;!dep[tto])</span><br><span class="line">			&#123;</span><br><span class="line">				dep[tto]=dep[now]+<span class="number">1</span>;</span><br><span class="line">				q[++r]=tto;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> dep[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,LL in)</span>	<span class="comment">//in不一定真的能用掉 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(now==t) <span class="keyword">return</span> in;</span><br><span class="line">	</span><br><span class="line">	LL out=<span class="number">0</span>;	<span class="comment">//in是前面流入这点的流量，out是这点向下层发出的总流量 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v=a[now];v;v=e[v].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> tto=e[v].to;</span><br><span class="line">		LL ww=e[v].w;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(ww&amp;&amp;dep[tto]==dep[now]+<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			LL res=<span class="built_in">dfs</span>(tto,<span class="built_in">min</span>(in,ww));</span><br><span class="line">			e[v].w-=res;</span><br><span class="line">			e[v^<span class="number">1</span>].w+=res;</span><br><span class="line">			in-=res;</span><br><span class="line">			out+=res;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!out) dep[now]=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LL x,y,z;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;s,&amp;t);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">		<span class="built_in">add</span>(x,y,z);</span><br><span class="line">		<span class="built_in">add</span>(y,x,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">bfs</span>()) ans+=<span class="built_in">dfs</span>(s,<span class="number">1e18</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/02/11/%E7%BD%91%E7%BB%9C%E6%B5%81/6.gif" alt="img"></p>
<p>注意理解多路增广：虽然一个点要枚举所有出边，但<strong>实质仍然是dfs</strong>，过程图类似于树。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/ZJUT-jiangnan/p/3632525.html">https://www.cnblogs.com/ZJUT-jiangnan/p/3632525.html</a></p>
<p><a href="https://blog.csdn.net/weixin_43907802/article/details/84705855">https://blog.csdn.net/weixin_43907802/article/details/84705855</a></p>
<p><a href="https://www.luogu.com.cn/problem/solution/P3376">https://www.luogu.com.cn/problem/solution/P3376</a></p>
]]></content>
      <categories>
        <category>算法比赛</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>质因数分解（待完善）</title>
    <url>/2022/03/23/%E8%B4%A8%E5%9B%A0%E6%95%B0%E5%88%86%E8%A7%A3/</url>
    <content><![CDATA[<p>时间复杂度：$O(\log n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 200000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[N+<span class="number">10</span>];			<span class="comment">//p[i]为i是否为素数</span></span><br><span class="line"><span class="type">int</span> vv[N+<span class="number">10</span>];			<span class="comment">//vv[i]为i的一个质因数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line">	p[i]=<span class="number">1</span>;</span><br><span class="line">	vv[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(N)+<span class="number">0.5</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(!p[i]) <span class="keyword">continue</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=i*<span class="number">2</span>;j&lt;=N;j+=i)</span><br><span class="line">	&#123;</span><br><span class="line">		p[j]=<span class="number">0</span>;</span><br><span class="line">		vv[j]=i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接除的方法使用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> f[N+<span class="number">10</span>];			<span class="comment">//f[i]为质因数i的个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(x&gt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	f[vv[x]]++;</span><br><span class="line">	x/=vv[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开辟vector记录所有分解结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; factors;		<span class="comment">//factors[i]为i的质因数分解结果</span></span><br><span class="line"></span><br><span class="line">factors.<span class="built_in">resize</span>(N+<span class="number">10</span>);</span><br><span class="line">	</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> temp=i;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(temp&gt;<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		factors[i].<span class="built_in">push_back</span>(vv[temp]);</span><br><span class="line">		temp/=vv[temp];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> p:factors[x]) f[p]++;		<span class="comment">//和直接除一样储存到f中的方法</span></span><br></pre></td></tr></table></figure>

<p>在$n$过大质因数数组无法存储时这一个数的求法：</p>
<p>需要先求得一个素数数组p[50010]，对于一个数的效率为$n^{1 \over 2}$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;p[i]*p[i]&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(n%p[i]==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		n/=p[i];</span><br><span class="line">		np[p[i]]++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n&gt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">50000</span>) np[n]++;</span><br><span class="line">	<span class="keyword">else</span> np[<span class="number">0</span>]+=n;		<span class="comment">//在np[0]处存储大素数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>似乎还有一种$n^{1 \over 4}$效率的求法，待完善。</p>
]]></content>
      <categories>
        <category>算法比赛</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>质因数分解</tag>
      </tags>
  </entry>
  <entry>
    <title>除法取模</title>
    <url>/2022/03/23/%E9%99%A4%E6%B3%95%E5%8F%96%E6%A8%A1/</url>
    <content><![CDATA[<p>由费马小定理可推出：${1 \over a} \% m &#x3D; a^{m - 2} \% m$，其中$m$为素数。</p>
<p>那么，${b \over a} \% m$就可以变成$b \cdot a^{m - 2} \% m$。</p>
<p>当$m$太大时，可以使用<strong>快速幂</strong>。</p>
<p><a href="https://blog.csdn.net/qq742762377/article/details/83278688">来源</a></p>
]]></content>
      <categories>
        <category>算法比赛</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>模运算</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2022/03/01/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>背包问题是一类特殊的动态规划问题。</p>
<p>如有需要，请优先看<a href="%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2.pdf">背包九讲</a>这篇文章，本文只是为了自己学习理解的翻版：）</p>
<h1 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h1><p><strong>题目：</strong></p>
<p>有$N$件物品和一个容量为$V$的背包。放入第$i$件物品占用的容量为$C_i$，得到的价值是$W_i$。求解一种价值总和最大的装法。</p>
<p><strong>基本思路：</strong></p>
<p>用子问题定义状态：$F[i,v]$表示前$i$件物品恰放入一个容量为$v$的背包可以获得的最大价值。则可得状态转换方程：<br>$$<br>F[i, v] &#x3D; \max { F[i - 1, v], F[i-1, v - C_i] + W_i }<br>$$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(F,<span class="number">0</span>,<span class="built_in">sizeof</span>(F));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v=C[i];v&lt;=V;v++)</span><br><span class="line">        F[i][v]=<span class="built_in">max</span>(F[i<span class="number">-1</span>][v],F[i<span class="number">-1</span>][v-C[i]]+W[i]);</span><br></pre></td></tr></table></figure>

<p>此方法时间与空间复杂度均为$O(VN)$。</p>
<p><strong>优化空间复杂度：</strong></p>
<p>空间复杂度可优化为$O(V)$。</p>
<p>发现只需要$i-1$个物品的状态就可以得出$i$个物品时的状态，因此可以进行压缩成两行的二维数组。</p>
<p>再次发现只需要容量小于$v$的状态就可以得出容量为$v$的状态，因此可以使用倒序压缩成一行的一维数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(F,<span class="number">0</span>,<span class="built_in">sizeof</span>(F));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v=V;v&gt;=C[i];v--)</span><br><span class="line">        F[v]=<span class="built_in">max</span>(F[v],F[v-C[i]]+W[i]);</span><br></pre></td></tr></table></figure>

<p>由于使用一维数组解01背包的程序在以后会多次用到，所以抽象出一个处理一件01背包中的物品的函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZeroOnePack</span><span class="params">(<span class="type">int</span> F[],<span class="type">int</span> C,<span class="type">int</span> W)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v=V;v&gt;=C;v--)</span><br><span class="line">        F[v]=<span class="built_in">max</span>(F[v],F[v-C]+W);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此原本的代码可以改写为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(F,<span class="number">0</span>,<span class="built_in">sizeof</span>(F));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    <span class="built_in">ZeroOnePack</span>(F,C[i],W[i]);</span><br></pre></td></tr></table></figure>

<p><strong>初始化细节问题：</strong></p>
<p>背包问题往往有两种不同的问法。有些要求<strong>必须把背包装满</strong>，有些则不必须。一种区别这两种问法的方法是使用不同的初始化方法。</p>
<ul>
<li>在要求装满时，初始化$F[0] &#x3D; 0$，$F[1..V] &#x3D; - \infty$。</li>
<li>在不要求装满时，初始化$F[0..V] &#x3D; 0$。</li>
</ul>
<p>可以这样理解：初始化的$F$数组就是在没有物品可放时背包的合法状态。当要求装满时，只有背包容量为0时可以在什么都不装时“恰好装满”，而其他容量均无解，属于未定义状态，因此应被赋值为$- \infty$；当不要求装满时，任意容量的背包都有“什么都不装”这一价值为0的合法解，因此初始值应全为$0$。</p>
<p>此技巧完全可以推广到其他类型的背包问题。</p>
<p><strong>一个常数优化：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v=V;v&gt;=C[i];v--)</span><br></pre></td></tr></table></figure>

<p>其中的第二重循环可以优化为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) sum+=W[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v=V;v&gt;=<span class="built_in">max</span>(V-sum,C[i]);v--)</span><br></pre></td></tr></table></figure>

<p>原理自己思考（提示：使用二维的转移方程思考较易）。</p>
<p><strong>小结：</strong></p>
<p>01背包问题时最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想。另外，别的类型的背包问题往往也可以转换成01背包问题求解。</p>
<h1 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h1><p><strong>题目：</strong></p>
<p>有$N$种物品和一个容量为$V$的背包，每种物品都有无限件可用。放入第$i$件物品占用的容量为$C_i$，得到的价值是$W_i$。求解一种价值总和最大的装法。</p>
<p><strong>基本思路：</strong></p>
<p>本问题与01背包问题唯一的不同是每种物品有无限件。因此从每种物品的角度考虑时，与它相关的策略不再是取或不取两种，而是取$0$件、取$1$件、取$2$件……直至取$\lfloor V &#x2F; C_i \rfloor$件等许多种。</p>
<p>若仍按照01背包的求解思路，仍然可以按照每种物品不同的策略写出状态转换方程：<br>$$<br>F[i,v] &#x3D; \max { F[i - 1, v - kC_i] + kW_i | 0 \leq kC_i \leq v }<br>$$<br>这跟01背包问题一样有$O(VN)$个状态需要求解，但求解每个状态的时间已经不再是常数了，求解状态$F[i,v]$的时间是$O({v \over C_i})$，总的复杂度可以认为是$O(NV \sum {V \over C_i})$，是比较大的。我们还是要试图该进这个复杂度。</p>
<p><strong>一个简单有效的优化：</strong></p>
<p>若两件物品$i$、$j$满足$C_i \leq C_j$且$W_i \geq W_j$，则可以将物品$j$直接去掉，不用考虑。</p>
<p>这个优化的正确性是显然的：任何情况下都可将价值小费用高的$j$换成物美价廉的$i$，得到的方案至少不会更差。对于随机生成的数据，这个方法往往会大大减少物品的件数，从而加快速度。然而这个并不能改善最坏情况的复杂度，因为有可能特别设计的数据可以一件物品也去不掉。</p>
<p>这个优化可以简单的$O(N^2)$地实现，一般都可以承受。另外，针对背包问题而言，比较不错的一种方法是：首先将费用大于V的物品去掉，然后使用类似计数排序的方法，计算出费用相同的物品中价值最高的是哪个，可以$O(V+N)$地完成这个优化。</p>
<p><strong>转化为01背包问题求解：</strong></p>
<p>最简单的想法是，考虑到第$i$种物品最多选$\lfloor V &#x2F; C_i \rfloor$件，于是可以把第$i$件物品转化为$\lfloor V &#x2F; C_i \rfloor$件相同的物品，然后求解此01背包问题。此做法完全没有改进时间复杂度，但其也指明了将完全背包问题转化为01背包问题的思路：将一种物品拆成多件只能选$0$件或$1$件的01背包中的物品。</p>
<p>更高效的转化方法是：把第$i$种物品拆成费用为$C_i2^k$、价值为$W_i2^k$的若干件物品，其中$k$取遍满足$C_i2^k \leq V$的非负整数。这使用了二进制的思想，因为不管最优策略选几件第$i$种物品，其件数写成二进制后，总能表示成若干个$2^k$件物品的和。这样一来每种物品被拆成了$O(\log \lfloor V &#x2F; C_i \rfloor)$件物品，是一个很大的的改进。</p>
<p><strong>$O(VN)$的算法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(F,<span class="number">0</span>,<span class="built_in">sizeof</span>(F));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v=C[i];v&lt;=V;v++)</span><br><span class="line">        F[v]=<span class="built_in">max</span>(F[v],F[v-C[i]]+W[i]);</span><br></pre></td></tr></table></figure>

<p>可以发现，此代码与01背包问题的代码只有$v$的循环次序不同而已。</p>
<p>那么为什么这个算法可行？首先思考为什么01背包要按照$v$递减的次序来循环：是为了保证第$i$次循环中的状态$F[i,v]$是由状态$F[i - 1,v - C_i]$递推而来。换句话说，也就是为了保证每件物品只选一次，保证在考虑“选入第$i$件物品”此决策时，依据的是一个尚未选入第$i$件物品的子结果$F[i - 1,v - C_i]$。而在完全背包问题中每件物品可选无限件，因此在考虑“加选一件第$i$种物品”这种策略时，正需要一个可能已经选入第$i$种物品的子结果$F[i,v - C_i]$，所以必须采用正循环。</p>
<p>值得一提的是，两层循环的次序可以颠倒。这个结论可能带来算法时间常数上的优化。</p>
<p>本算法也可由其他思路得出。例如，将<strong>基本思路</strong>中求解$F[i,v - C_i]$的状态转换方程写出来：<br>$$<br>F[i,v - C_i] &#x3D; \max { F[i - 1, v - (k + 1)C_i] + kW_i | C_i \leq (k + 1)C_i \leq v }<br>$$<br>回看<strong>基本思路</strong>中的原方程：<br>$$<br>F[i,v] &#x3D; \max { F[i - 1, v - kC_i] + kW_i | 0 \leq kC_i \leq v }<br>$$<br>将原本$k &#x3D; 0$的情况抽离出来：<br>$$<br>F[i,v] &#x3D;\max (F[i-1, v], \max { F[i - 1, v - (k+1)C_i] + (k+1)W_i | 0 \leq (k+1)C_i \leq v })<br>$$<br>将$W_i$从$\max$中提出：<br>$$<br>F[i,v] &#x3D;\max (F[i-1, v], \max { F[i - 1, v - (k+1)C_i] + kW_i | 0 \leq (k+1)C_i \leq v } + W_i)<br>$$<br>注意到式中一部分与求解$F[i,v - C_i]$的状态转换方程完全一致，进行替换，得到：<br>$$<br>F[i,v] &#x3D; \max ( F[i - 1, v], F[i, v - C_i] + W_i )<br>$$<br>将这个方程用一维数组实现，便得到了上面的代码。</p>
<p>最后抽象出处理一件完全背包类物品的过程代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CompletePack</span><span class="params">(<span class="type">int</span> F[],<span class="type">int</span> C,<span class="type">int</span> W)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v=C;v&lt;=V;v++)</span><br><span class="line">        F[v]=<span class="built_in">max</span>(F[v],F[v-C]+W);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结：</strong></p>
<p>完全背包也是一个相当基础的背包问题，他有两个状态转移方程。</p>
<h1 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h1><p><strong>题目：</strong></p>
<p>有$N$种物品和一个容量为$V$的背包，第$i$种物品最多有$M_i$件可用。放入第$i$件物品占用的容量为$C_i$，得到的价值是$W_i$。求解一种价值总和最大的装法。</p>
<p><strong>基本思路：</strong></p>
<p>这题目和完全背包问题很类似，只需稍微更改完全背包问题的方程即可。</p>
<p>对于第$i$件物品有$M_i + 1$种策略：取$0$件，取$1$件……取$M_i$件。令$F[i,v]$表示前$i$种物品恰放入一个容量为$v$的背包的最大价值，则有：<br>$$<br>F[i,v] &#x3D; \max { F[i - 1, v - kC_i] + kW_i | 0 \leq k \leq M_i }<br>$$<br>复杂度是$O(V \sum M_i)$。</p>
<p><strong>转化为01背包问题：</strong></p>
<p>把第$i$种物品换成$M_i$件01背包种的物品，则得到了物品数位$\sum M_i$的01背包问题。直接求解之，复杂度仍是$O(V \sum M_i)$。但是我们期望转化为01背包问题后，能够像完全背包一样降低复杂度。</p>
<p>仍然考虑二进制的思想，把第$i$种物品分解成若干件01背包中的物品，设一系列系数分别为$2^0, 2^1, 2^2, … , 2^{k - 1}, M_i - 2^k + 1$，且$k$是满足$M_i - 2^k + 1 &gt; 0$的最大整数，每件物品的费用为$系数 * C_i$、价值为$系数 * W_i$。（也就是把$M_i$件物品按照二进制分组了）例如：若$M_i &#x3D; 14$，则相应的$k &#x3D; 3$，这种最多取14件的物品应被分成系数分别为$1, 2, 4, 7$的四件物品。这样就将第$i$种物品分成了$O(\log M_i)$种物品，将原问题转化为了复杂度位$O(V \sum \log M_i)$的01背包问题，是很大的改进。</p>
<p>下面给出$O(\log M)$时间处理一件多重背包中物品的过程：（暂时未验证编译是否通过）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MultiplePack</span><span class="params">(<span class="type">int</span> F[],<span class="type">int</span> C,<span class="type">int</span> W,<span class="type">int</span> M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(C*M&gt;=V)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CompletePack</span>(F,C,W);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k&lt;M)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ZeroOnePack</span>(F,k*C,k*W);</span><br><span class="line">        M-=k;</span><br><span class="line">        k*=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ZeroOnePack</span>(F,M*C,M*W);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可行性问题$O(VN)$的算法：</strong></p>
<p>当问题是“每种有若干件的物品能否填满给定容量的背包”，即只需考虑填满背包的可行性，不需考虑每件物品的价值时，多重背包问题同样有$O(VN)$复杂度的算法。</p>
<p>例如，可以使用单调队列的数据结构，优化基本算法的状态转移方程，使每个状态的至可以以均摊$O(1)$的时间求解。</p>
<p>下面介绍另一种算法，其基本思想为：设$F[i,j]$表示“用了前$i$种物品填满容量位$j$的背包后，最多还剩下几个第$i$种物品可用”，如果$F[i,j] &#x3D; -1$则说明这种状态不可行，若可行应满足$0 \leq F[i,j] \leq M_i$。</p>
<p>递推求$F[i,j]$的代码如下：（暂时未验证编译是否通过）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">F[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=V;i++) F[<span class="number">0</span>][i]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=V;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(F[i<span class="number">-1</span>][j]&gt;=<span class="number">0</span>) F[i][j]=M[i];</span><br><span class="line">        <span class="keyword">else</span> F[i][j]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=V;j++)</span><br><span class="line">        <span class="keyword">if</span>(F[i][j]&gt;<span class="number">0</span>) F[i][j+C[i]]=<span class="built_in">max</span>(F[i][j+C[i]],f[i][j]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终$F[N][0…V]$便是多重背包可行性问题的答案。</p>
<p><strong>小结：</strong></p>
<p>我们看到了将一个算法的复杂度由$O(V \sum M_i)$改进到$O(V \sum \log M_i)$的过程，还知道了存在复杂度为$O(VN)$的算法。应特别注意“拆分物品”的思想和方法。</p>
<h1 id="混合三种背包问题"><a href="#混合三种背包问题" class="headerlink" title="混合三种背包问题"></a>混合三种背包问题</h1><p><strong>问题：</strong></p>
<p>将前三种背包问题混合起来，有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取有限次（多重背包）。</p>
<p><strong>01背包与完全背包的混合：</strong></p>
<p>由于01背包和完全背包的代码中只有一处不同，故在只有这两种物品时，只要根据物品的类别选用循环顺序即可，复杂度是$O(VN)$：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(第i件物品属于<span class="number">01</span>背包)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v=V;v&gt;=C[i];v--)</span><br><span class="line">            F[v]=<span class="built_in">max</span>(F[v],F[v-C[i]]+W[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(第i件物品属于完全背包)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v=C[i];v&lt;=V;v++)</span><br><span class="line">            F[v]=<span class="built_in">max</span>(F[v],F[v-C[i]]+W[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>再加上多重背包：</strong></p>
<p>利用单调队列，可以给出均摊$O(VN)$的解法。但如果不考虑单调队列的话，用将每个多重背包的物品分成$O(\log M_i)$个01背包的物品的方法也已经很优了。此时最清晰的写法是调用前面给出的三个过程。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(第i件物品属于<span class="number">01</span>背包)</span><br><span class="line">        <span class="built_in">ZeroOnePack</span>(F,C[i],W[i]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(第i件物品属于完全背包)</span><br><span class="line">        <span class="built_in">CompletePack</span>(F,C[i],W[i]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(第i件物品属于完全背包)</span><br><span class="line">        <span class="built_in">MultiplePack</span>(F,C[i],W[i],N[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在最初写出这三个过程的时候，可能完全没有想到它们会在这里混合应用。这似乎就体现了编程中抽象的威力。</p>
<p><strong>小结：</strong></p>
<p>有人说，困难的题目都是由简单的题目叠加而来的。这句话是否公里暂且存之不论，但它在本节中已经得到了充分的体现。只要基础扎实，领会三种基本背包问题的思想，就可以做到把困难的题目拆分成简单的题目来解决。</p>
<h1 id="二维费用的背包问题"><a href="#二维费用的背包问题" class="headerlink" title="二维费用的背包问题"></a>二维费用的背包问题</h1><p><strong>问题：</strong></p>
<p>此问题与01背包问题的不同为：第$i$件物品有两种所需的费用分别为$C_i$和$D_i$，两种费用分别对应的背包容量为$V$和$U$。</p>
<p><strong>思路：</strong></p>
<p>费用增加了一维，状态也增加一维即可。设$F[i, v, u]$表示前$i$件物品符出两种费用分别为$v$和$u$时可获得的最大价值。状态转移方程就是：<br>$$<br>F[i, v, u] &#x3D; \max { F[i - 1, v, u], F[i - 1, v - C_i, u - D_i] + W_i }<br>$$<br>如前述优化空间复杂度的方法，可以只使用二维的数组：当每件物品只有一件时变量$v$和$u$采用逆序的循环，当有无限件时采用顺序循环，当有有限件时拆分物品。</p>
<p><strong>物品总个数的限制：</strong></p>
<p>“二维费用”的条件有时会用隐含的方式给出，如：最多只能取$U$件物品。这事实上相当于每件物品多了一种“件数”的费用。每个物品的件数费用均为$1$，可以付出的最大件数费用为$U$。换句话说，设$F[v, u]$表示符出费用$v$，最多选$u$件时可得到的最大价值，则根据物品的类型（01、完全、多重）用不同的方法循环更新，最后在$F[0…V, 0…U]$范围内寻找答案。</p>
<p><strong>复整数域上的背包问题：</strong></p>
<p>另一种看代二维背包问题的思路是：将他看待成复整数域上的背包问题。也就是说，背包的容量以及每件物品的费用都是一个复整数。而常见的一维背包问题则是自然数域上的背包问题。</p>
<p>作为这种思想的练习，可以尝试将后文中提到的“子集和问题”扩展到二维，并试图用同样的复杂度解决。</p>
<p><strong>小结：</strong></p>
<p>面对由熟悉的动态规划题目变形得来的题目时，在原来的状态中加一维以满足新的限制是一种比较通用的方法。</p>
<h1 id="分组的背包问题"><a href="#分组的背包问题" class="headerlink" title="分组的背包问题"></a>分组的背包问题</h1><p><strong>问题：</strong></p>
<p>有$N$件物品和一个容量为$V$的背包。放入第$i$件物品占用的容量为$C_i$，得到的价值是$W_i$。这些物品被划分为$K$组，每组中的物品互相冲突，最多选一件。求解一种价值总和最大的装法。</p>
<p><strong>思路：</strong></p>
<p>这个问题变成了每组物品有若干种策略：是选择本组的某一件，还是一件都不选。也就是说设$F[k, v]$表示前$k$组物品放入一个容量为$v$的背包能取得的最大权值，则有：<br>$$<br>F[k, v] &#x3D; \max { F[k - 1, v], F[k - 1, v - C_i] + W_i | item \ i \in group \ k }<br>$$<br>使用一维数组的代码如下：（暂时未验证编译是否通过）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=K;k++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v=V;v&gt;=<span class="number">0</span>;v--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=a[k];i;i=e[i].next)</span><br><span class="line">            F[v]=<span class="built_in">max</span>(F[v],f[v-C[i.id])+W[i.id];</span><br></pre></td></tr></table></figure>

<p>这里三层循环的顺序保证了每一组内的物品最多只有一个会被添加到背包中。</p>
<p>另外，显然可以对每组内的物品应用“若两件物品$i$、$j$满足$C_i \leq C_j$且$W_i \geq W_j$，则可以将物品$j$直接去掉，不用考虑。”这个优化。</p>
<p><strong>小结：</strong></p>
<p>分组背包问题将彼此互斥的若干物品成为一个组，这建立了一个很好的模型。不少背包问题的变形都可以转化为分组的背包问题（如下一节的<strong>有依赖的背包问题</strong>），由分组的背包问题进一步可定义“泛化物品”的概念，十分有利于解题。</p>
<h1 id="有依赖的背包问题"><a href="#有依赖的背包问题" class="headerlink" title="有依赖的背包问题"></a>有依赖的背包问题</h1><p><strong>问题：</strong></p>
<p>这种背包问题的物品件存在某种“依赖”的关系。也就是说，物品$i$依赖于物品$j$，表示若选物品$i$，则必须选物品$j$。为了简化起见，我们先设没有某个物品既依赖于别的物品，又被别的物品所依赖；另外，没有某件物品同时依赖多件物品。</p>
<p><strong>思路：</strong></p>
<p>这个问题由NOIP2006中“金明的预算方案”一题扩展而来。遵从该题的提法，将不依赖于别的物品的物品称为“主件”，依赖于某主件的物品称为“附件”。由此可知所有的物品由若干主件和依赖于每个主件的一个附件集合组成。</p>
<p>按照背包问题的一般思路，仅考虑一个主件和它的附件集合。可是，可用的策略非常多，包括：都不选，仅选择主件，选择主件和一个附件，选择主件和两个附件……无法用状态转移方程来表示如此多的策略。事实上，设有n个附件，则策略有$2^n + 1$个，为指数级。</p>
<p>考虑到所有的这些策略都是互斥的（也就是说，你只能选择一种策略），所以一个主件和他的附件集合实际上对应于<strong>分组的背包问题</strong>中的一个物品组，每个选择了主件又选择了若干个附件的策略对应于这个物品组中的一个物品，其费用和价值都是这个策略中物品的值的和。但仅仅是这一步转化并不能给出一个好的算法，因为物品组中的物品还是像原问题的策略一样多。</p>
<p>再考虑对每组内的物品应用“若两件物品$i$、$j$满足$C_i \leq C_j$且$W_i \geq W_j$，则可以将物品$j$直接去掉，不用考虑。”这个优化。我们可以想到，对于第$k$个物品组中的物品，所有费用相同的物品只留一个价值最大的，不影响结果。所以，可以对主件$k$的“附件集合”先进行一次01背包，得到费用依次为$0…V - C_k$所有这些值时相应的最大价值$F_k[0…V - C_k]$。那么，这个主件及它的附件集合相当于$V - C_k + 1$个物品的物品组，其中费用为$v$的物品的价值为$F_k[v - C_k] + W_k$，$v$的取值范围是$C_k \leq v \leq V$。</p>
<p>也就是说，原来指数级的策略中，有很多策略都是冗余的。通过依次01背包后，将主件$k$及其附件转化为$V - C_k + 1$个物品的物品组，就可以直接应用<strong>分组的背包问题</strong>的算法解决问题了。</p>
<p><strong>较一般的问题：</strong></p>
<p>更一般的问题是：依赖关系以图论中“森林”的形式给出。也就是说，主件的附件仍然可以具有自己的附件集合。限制指示每个物品最多只依赖于一个物品（只有一个主件）且不出现循环依赖。</p>
<p>解决这个问题仍然可以用将每个主件及其附件集合转化为物品组的方式。唯一不同的是，由于附件可能还有附件，就不能将每个附件都看作一个一般的01背包中的物品了。若这个附件也有附件集合，则它必定要被先转化为物品组，然后用<strong>分组的背包问题</strong>解出主件及其附件集合所对应的附件组中各个费用的附件所对应的价值。</p>
<p>事实上，这是一种树形动态规划，其特点是，在用动态规划求每个父节点的属性之前，需要对它的各个儿子的属性进行一次动态规划式的求值。这已经触及到了“泛化物品”的思想。看完<strong>泛化物品</strong>后，你会发现这个“依赖关系树”每一个子树都等价于一件泛化物品，求某节点为根的子树对应的泛化物品相当于求其所有儿子的对应的泛化物品之和。</p>
<p><strong>小结：</strong></p>
<p>用物品组的思想考虑那题中及其特殊的依赖关系：物品不能既作主件又作附件，每个主件最多有两个附件，可以发现一个主件和它的两个附件等价于一个由四个物品组成的物品组，这便揭示了问题的某种性质。</p>
<h1 id="泛化物品"><a href="#泛化物品" class="headerlink" title="泛化物品"></a>泛化物品</h1><p><strong>定义：</strong></p>
<p>考虑这样一种物品，它并没有固定的费用和价值，而是它的价值随着你分配给它的费用而变化。这就是泛化物品的概念。、</p>
<p>更严格的定义之。在背包容量为$V$的背包问题中，泛化物品是一个定义域为$0…V$中的整数的函数$h$，当分配给它的费用为$v$时，能得到的价值就是$h(v)$。</p>
<p>这个定义有一点点抽象，另一种理解是一个泛化物品就是一个数组$h[0…V]$，给它费用$v$，可得到价值$h[v]$。</p>
<p>一个费用为$c$价值为$w$的物品，如果它是01背包中的物品，那么把它看成泛化物品，它就是除了$h(c) &#x3D; w$外，其他函数值都为$0$的一个函数，如果它是完全背包中的物品，那么它可以看成这样一个函数，仅当$v$被$c$整除时有$h(v) &#x3D; w \cdot {v \over c}$，其它函数值均为$0$。如果它是多重背包中重复次数最多为$m$的物品，那么它对应的泛化物品的函数有$h(v) &#x3D; w \cdot {v \over c}$仅当$v$被$c$整除且${v \over c} \leq n$，其他情况函数值均为$0$。</p>
<p>一个物品组可以看作一个泛化物品$h$。对于一个$0…V$中的$v$，若物品组中不存在费用为$v$的物品，则$h(v) &#x3D; 0$，否则$h(v)$取值为所有费用为$v$的物品的最大价值。<strong>有依赖的背包问题</strong>中每个主件及其附件集合等价于一个物品组，自然也可看做一个泛化物品。</p>
<p><strong>泛化物品的和：</strong></p>
<p>如果给定了两个泛化物品$h$和$l$，要用一定的费用从这两个泛化物品中获得最大的价值，这个问题怎么求呢？事实上，对于一个给定的费用$v$，只需枚举将这个费用如何分配给两个泛化物品就可以了。同样的，对于$0…V$中的每一个整数$v$，可以求得费用$v$分配到$h$和$l$中的最大价值$f(v)$。也即：<br>$$<br>f(v) &#x3D; \max { h(k) + l(v - k) | 0 \leq k \leq v }<br>$$<br>可以看到，这里的$f$是一个由泛化物品$h$和$l$决定的定义域为$0…V$的函数，也就是说，$f$是一个由泛化物品$h$和$l$决定的泛化物品。</p>
<p>我们将$f$定义为泛化物品$h$和$l$的和：$h$、$l$都是泛化物品，若函数$f$满足以上关系式，则称$f$是$h$与$l$的和。泛化物品和运算的时间复杂度取决于背包的容量，是$O(V_2)$。</p>
<p><strong>背包问题的泛化物品：</strong></p>
<p>一个背包问题中，可能会给出很多条件，包括每种物品的费用、价值等属性，物品之间的返祖、依赖等关系等。但肯定能将问题对应于某个泛化物品。也就是说，给定了所有条件以后，就可以对每个非负整数$v$求得：若背包容量为$v$，将物品装入背包可得到的最大价值是多少，这可以认为是定义在非负整数集上的一件泛化物品。这个泛化物品——或者说问题所对应的一个定义域为非负整数的函数——包含了关于问题本身的高度浓缩的信息。一般而言，求得这个泛化物品的一个子定义域（例如$0…V$）的值之后，就可以根据这个函数的取值得到背包问题的最终答案。</p>
<p>综上所述，一般而言，求解背包问题，即求解这个问题所对应的一个函数，即该问题的泛化物品。而求解某个泛化物品的一种常用方法就是将它表示为若干泛化物品的和然后求之。</p>
<p><strong>小结：</strong></p>
<p>本讲是原作者在学习函数式编程的Scheme语言时，用函数编程的眼光审视各类背包问题得出的结论。</p>
<h1 id="背包问题问法的变化"><a href="#背包问题问法的变化" class="headerlink" title="背包问题问法的变化"></a>背包问题问法的变化</h1><p>以上涉及的各种背包问题都是要求在背包容量（费用）的限制下求可以取到的最大价值，但背包问题还有很多灵活的问法，在这里值得提一下。</p>
<p>例如，求解最多可以放多少件物品或者最多可以装满多少背包的空间。这都可以根据具体问题利用前面的方程求出所有状态的值（$F$数组）之后得到。</p>
<p>还有，如果要求的是“总价值最小”“总件数最小”，只需将状态转移方程中的$\max$改成$\min$即可。</p>
<p>下面说一些变化更大的问法。</p>
<p><strong>输出方案：</strong></p>
<p>一般而言，背包问题是要求一个最优值，如果要求输出这个最优值的方案，可以参照一般动态规划问题输出方案的方法：记录下每个状态的最优值是由状态转移方程的哪一项推出来的，换句话说，记录下它是由哪一个策略推出来的。便可根据这条策略找到上一个状态，从上一个状态接着向前推即可。</p>
<p>还是以01背包为例，方程为$F[i, v] &#x3D; \max { F[i - 1, v], F[i-1, v - C_i] + W_i }$。再用一个数组$G[i, v]$，设$G[i, v] &#x3D; 0$表示推出$F[i, v]$的值时是采用了方程的前一项（也即$F[i, v] &#x3D; F[i - 1, v]$），$G[i, v] &#x3D; 1$表示采用了方程的后一项。注意这两项分别表示了两种策略：未选第$i$个物品及选了第$i$个物品。那么输出方案的代码可以这样写：（暂时未验证编译是否通过）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i=N,v=V;</span><br><span class="line"><span class="keyword">while</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(G[i][v]==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;未选第%d项物品&quot;</span>,i);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(G[i][v]==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;选了第%d项物品&quot;</span>,i);</span><br><span class="line">        v-=-C[i];</span><br><span class="line">    &#125;</span><br><span class="line">    i--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，采用方程的前一项或后一项也可以在输出方案的过程中根据$F[i, v]$的值实时地求出来。也即，不须记录$G$数组，将上述代码改为如下形式也可：（暂时未验证编译是否通过）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i=N,v=V;</span><br><span class="line"><span class="keyword">while</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(F[i][v]==F[i<span class="number">-1</span>][v]) <span class="built_in">printf</span>(<span class="string">&quot;未选第%d项物品&quot;</span>,i);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(F[i][v]==F[i<span class="number">-1</span>][v-C[i]]+W[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;选了第%d项物品&quot;</span>,i);</span><br><span class="line">        v-=-C[i];</span><br><span class="line">    &#125;</span><br><span class="line">    i--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出字典序最小的最优方案：</strong></p>
<p>这里”字典序最小“的意思是$1…N$号物品的选择方案排列出来以后字典序最小。以输出01背包最小字典序的方案为例。</p>
<p>一般而言，求一个字典序最小的最优方案，只需要在转移时注意策略。</p>
<p>首先，子问题的定义要略改一些。我们注意到，如果存在一个选了物品$1$的最优方案，那么答案一定包含物品$1$，原问题转化为一个背包容量为$V - C_1$，物品为$2…N$的子问题反之，如果答案不包含物品$1$，则转化成背包容量仍为$V$，物品为$2…N$的子问题。</p>
<p>不管答案怎样，子问题的物品都是以$i…N$而非前述的$1…i$的形式来定义的，所以状态的定义和转移方程都需要改一下。</p>
<p>但也许更简易的方法是，先把物品编号做$x &#x3D; N + 1 - x$的变换，在输出方案时再变换回来。再做完物品编号的变换后，可以按照前面经典的转移方程来求值。只是在输出方案时要注意，如果$F[i, v] &#x3D; F[i - 1, v]$和$F[i, v] &#x3D; F[i - 1][v - C_i] + W_i$都成立，应该按照后者来输出方案，即选择了物品$i$，输出其原来的编号$N - 1 - i$。</p>
<p><strong>求总方案数：</strong></p>
<p>对于一个给定了背包容量、物品费用、物品间相互关系（分组、依赖等）的背包问题，除了再给定每个物品的价值后求可得到的最大价值外，还可以得到装满背包或将背包装至某一指定容量的方案总数。</p>
<p>对于这类改变问法的问题，一般只需将状态转移方程中的$\max$改成sum即可。例如若每件物品均是完全背包中的物品，转移方程即为：<br>$$<br>F[i, v] &#x3D; sum{ F[i - 1, v], F[i, v - C_i] }<br>$$<br>初始条件是$F[0, 0] &#x3D; 1$。</p>
<p>事实上，这样做可行的原因在于状态转移方程已经考察了所有可能的背包组成方案。</p>
<p><strong>最优方案的总数：</strong></p>
<p>这里的最优方案是指物品总价值最大的方案。以01背包为例。</p>
<p>结合求最大总价值和方案总数两个问题的思路，最优方案的总数可以这样求：$F[i, v]$代表该状态的最大价值，$G[i, v]$表示这个子问题的最优方案的总数，则在求$F[i, v]$的同时求$G[i, v]$的代码如下：（暂时未验证编译是否通过）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">G[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v=V;v&gt;=<span class="number">0</span>;v--)</span><br><span class="line">    &#123;</span><br><span class="line">        F[i][v]=<span class="built_in">max</span>(F[i<span class="number">-1</span>][v],F[i<span class="number">-1</span>][v-C_i]+W[i]);</span><br><span class="line">        G[i][v]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(F[i][v]==F[i<span class="number">-1</span>][v]) G[i][v]+=G[i<span class="number">-1</span>][v];</span><br><span class="line">        <span class="keyword">if</span>(F[i][v]==F[i<span class="number">-1</span>][v-C[i]]+W[i]) G[i][v]+=G[i<span class="number">-1</span>][v-C[i]];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>求次优解、第$K$优解：</strong></p>
<p>对于求次优解、第$K$优解类的问题，如果相应的最优解问题能写出状态转移方程、用动态规划解决，那么求次优解往往可以相同的复杂度解决，第$K$优解则比求最优解的复杂度上多一个系数$K$。</p>
<p>其基本思想时，将每个状态都表示成有序队列，将状态转移方程中的$\max &#x2F; \min$转化成有序队列的合并。</p>
<p>这里仍以01背包为例进行讲解。</p>
<p>首先看01背包求最优解的状态转移方程：$F[i, v] &#x3D; \max { F[i - 1, v], F[i-1, v - C_i] + W_i }$。如果要求第$K$优解，那么状态$F[i, v]$就应该是一个大小为$K$的队列$F[i, v, 1…K]$。其中$F[i, v, k]$表示前$i$个物品中，背包大小为$v$时，第$k$优解的值。这里也可以简单地理解为在原来的方程中加了一维来表示结果的优先次序。显然$F[i, v, 1…K]$这$K$个数是由大到小排列的，所以它可看作是一个有序队列。</p>
<p>然后原方程就可以解释为：$F[i, v]$这个有序队列是由$F[i - 1, v]$和$F[i - 1, v - C_i] + W_i$这两个有序队列合并得到的。前者$F[i - 1, v]$即$F[i - 1, v, 1…K]$，后者$F[i - 1, v - C_i] + W_i$则理解为在$F[i - 1, v - C_i, 1…K]$的每个数上加上$W_i$后得到的有序队列。合并这两个有序队列并将结果的前$K$项储存到$F[i, v, 1…K]$中的复杂度是$O(K)$。最后的第$K$优解的答案是$F[N, V, K]$。总的时间复杂度是$O(NVK)$。</p>
<p>为什么这个方法正确呢？实际上，一个正确的状态转移方程的求解过程遍历了所有可用的策略，也就覆盖了问题的所有方案。只不过由于是求最优解，所以其它在任何一个策略上达不到最优的方案都被忽略了。如果把每个状态表示成一个大小为$K$的数组，并在这个数组中有序地保存该状态可取到的前$K$个最优值。那么，对于任两个状态的$\max$运算等价于两个由大到小的有序队列的合并。</p>
<p>另外还要注意题目对于“第$K$优解”的定义，是要求将策略不同但权值相同的两个方案是看作同一个解还是不同的解。如果是前者，则维护有序队列时要保证队列里的数没有重复的。</p>
<p><strong>小结：</strong></p>
<p>显然，这里不可能穷尽背包类动态规划问题所有的问法。甚至还存在一类将背包类动态规划问题与其他领域（例如数论、图论）结合起来的问题，在这篇论背包问题的专文中也不会论及。但只要深刻领会前述所有类别的背包问题的思路和状态转移方程，遇到其它的变形问题，应该也不难想出算法。</p>
<p>触类旁通、举一反三，应该也是一个程序员应有的品质吧。</p>
]]></content>
      <categories>
        <category>算法比赛</category>
      </categories>
      <tags>
        <tag>背包问题</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
</search>
